<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SM copy</title>
    <style>
        :root {
            color-scheme: dark;
            --angled-radius: 16px;
        }
        html, body {
            height: 100%;
            margin: 0;
            background: #050505;
            color: #fff;
            font-family: "Segoe UI", Tahoma, sans-serif;
            overflow: hidden;
            user-select: none;
        }
        #gameCanvas {
            width: 100%;
            height: 100%;
            display: block;
            outline: none;
            background: radial-gradient(circle at center, #0a0a0a, #010101);
            cursor: crosshair;
        }
        #fallback {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            padding: 20px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background: rgba(0, 0, 0, 0.7);
        }
        #menuOverlay,
        #inventoryOverlay {
            position: fixed;
            inset: 0;
            background: transparent;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 40px 20px 120px;
            gap: 20px;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease;
        }
        #menuOverlay {
            z-index: 12;
            background: transparent;
        }
        #inventoryOverlay { z-index: 6; }
        #menuOverlay.visible,
        #inventoryOverlay.visible {
            opacity: 1;
            pointer-events: auto;
        }
        #menuOverlay h2,
        #inventoryOverlay h3 {
            margin: 0;
            letter-spacing: 2px;
            text-transform: uppercase;
            width: 100%;
            text-align: center;
        }
        .menuPage {
            width: min(480px, 90%);
            display: none;
            flex-direction: column;
            gap: 24px;
            flex: 1;
            min-height: 0;
            overflow: auto;
            padding-right: 6px;
            padding-bottom: 70px;
            scrollbar-width: thin;
            scrollbar-color: #f2d24b rgba(12, 12, 18, 0.6);
            border-radius: 0 var(--angled-radius) 0 var(--angled-radius);
        }
        .menuPage.active {
            display: flex;
        }
        .menuPage[data-page="main"] {
            align-items: center;
            justify-content: center;
            overflow: visible;
            padding: clamp(24px, 4vw, 80px);
            gap: 0;
        }
        .sliderRow {
            display: flex;
            align-items: center;
            gap: 14px;
        }
        .sliderRow label {
            margin: 0;
            white-space: nowrap;
        }
        .sliderRow input[type="range"] {
            flex: 1;
            width: auto;
            min-width: 0;
        }
        input[type="range"] {
            width: 100%;
        }
        .menuButtons,
        .controlsTable {
            display: flex;
            flex-direction: column;
            gap: 14px;
        }
        .pauseMenuCard {
            position: relative;
            width: min(374px, 68vw);
            padding: 250px 22px 240px;
            border-radius: 18px;
            border: none;
            background: url('Data/Gui/Resolutions/1920x1080/BackgroundImages/gui_background_menu_tab.png') top center / contain no-repeat;
            box-shadow: none;
            display: flex;
            flex-direction: column;
            gap: 14px;
            align-items: center;
        }
        .pauseMenuIcon {
            display: none !important;
        }
        .pauseMenuButtons {
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        .pauseMenuButton {
            border-radius: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: 600;
            border: 1px solid rgba(255, 255, 255, 0.28);
            background: rgba(0, 0, 0, 0.2);
            transition: border-color 0.15s ease, box-shadow 0.15s ease, background 0.15s ease, color 0.15s ease;
        }
        .pauseMenuButton:hover {
            background: rgba(0, 0, 0, 0.2);
            border-color: rgba(255, 255, 255, 0.85);
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.25);
        }
        .pauseMenuButton.primary {
            border-color: #f0c255;
            color: #f6d36b;
            background: rgba(0, 0, 0, 0.25);
        }
        .pauseMenuButton.primary:hover {
            background: #f0c255;
            color: #1b1b1b;
            border-color: rgba(255, 255, 255, 0.95);
            box-shadow: 0 0 12px rgba(255, 255, 255, 0.35);
        }
        button,
        .keyButton {
            padding: 10px 22px;
            border-radius: 0 var(--angled-radius) 0 var(--angled-radius);
            border: 1px solid rgba(255, 255, 255, 0.3);
            background: rgba(0, 0, 0, 0.5);
            color: #fff;
            cursor: pointer;
        }
        button:hover,
        .keyButton:hover {
            background: rgba(255, 255, 255, 0.1);
        }
        .controlsTable {
            gap: 8px;
            flex: 0 0 auto;
            overflow: visible;
            width: 100%;
        }
        .controlRow {
            display: grid;
            grid-template-columns: 1fr 170px 170px;
            gap: 10px;
            align-items: center;
        }
        .optionsPane[data-tab-panel="controls"] .optionsGrid {
            column-gap: 32px;
        }
        .optionsPane[data-tab-panel="controls"] .controlRow {
            grid-template-columns: 1fr 155px 155px;
            column-gap: 6px;
        }
        .controlLabel {
            font-size: 0.95rem;
        }
        .keyButton.listening {
            border-color: #ffb347;
            color: #ffb347;
            background: rgba(255, 179, 71, 0.1);
            animation: pulse 1s linear infinite;
        }
        @keyframes pulse {
            0% { box-shadow: 0 0 0 rgba(255, 179, 71, 0.2); }
            50% { box-shadow: 0 0 12px rgba(255, 179, 71, 0.6); }
            100% { box-shadow: 0 0 0 rgba(255, 179, 71, 0.2); }
        }
        .menuBackBar {
            position: fixed;
            left: 0;
            right: 0;
            bottom: 20px;
            width: 100%;
            display: flex;
            justify-content: center;
            padding: 0;
            margin-top: 0;
            background: linear-gradient(transparent, rgba(5, 5, 8, 0.6));
        }
        .optionsShell {
            width: min(1180px, 92vw);
            height: min(740px, 78vh);
            display: flex;
            flex-direction: column;
            gap: 14px;
            padding: 18px 20px 22px;
            background:
                linear-gradient(160deg, rgba(35, 38, 44, 0.95), rgba(15, 16, 22, 0.9));
            border-radius: 0 var(--angled-radius) 0 var(--angled-radius);
            border: 1px solid rgba(255, 255, 255, 0.08);
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.45);
        }
        .menuPage[data-page="options"] {
            width: min(1200px, 92vw);
            padding-right: 0;
            padding-bottom: 0;
            overflow: hidden;
        }
        .optionsTopBar {
            display: grid;
            grid-template-columns: 1fr auto 1fr;
            align-items: center;
            gap: 16px;
            padding: 12px 16px;
            background: rgba(0, 0, 0, 0.35);
            border-radius: 0 var(--angled-radius) 0 var(--angled-radius);
            border: 1px solid rgba(255, 255, 255, 0.06);
        }
        .optionsTopLeft {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        .optionsTitle {
            text-transform: uppercase;
            letter-spacing: 4px;
            font-weight: 600;
            font-size: 1.15rem;
            color: #f2d5a1;
            justify-self: center;
        }
        .optionsTopRight {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
        }
        .optionsKeyHint {
            padding: 6px 10px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background: rgba(0, 0, 0, 0.35);
            font-size: 0.75rem;
            letter-spacing: 1px;
            color: rgba(255, 255, 255, 0.75);
        }
        .optionsActionBtn,
        .optionsBackBtn {
            border-radius: 12px;
            padding: 8px 18px;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-size: 0.75rem;
        }
        .optionsShell .keyButton {
            border-radius: 12px;
        }
        .optionsActionBtn.primary {
            border-color: rgba(255, 215, 120, 0.8);
            color: #f6d36b;
        }
        .optionsTabs {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
            padding: 8px 10px;
            background: rgba(0, 0, 0, 0.25);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.08);
            text-transform: uppercase;
            letter-spacing: 1px;
            font-size: 0.75rem;
        }
        .optionsTab {
            position: relative;
            padding: 6px 18px 8px 22px;
            border-radius: 10px 10px 0 0;
            border: 1px solid rgba(255, 255, 255, 0.18);
            background: rgba(220, 220, 220, 0.16);
            color: rgba(255, 255, 255, 0.75);
            cursor: pointer;
            clip-path: polygon(0 100%, 100% 100%, calc(100% - 8px) 0, 8px 0);
        }
        .optionsTab.active {
            color: #1b1b1b;
            border-color: rgba(255, 255, 255, 0.18);
            background: linear-gradient(180deg, #f6d36b, #e2b04c);
        }
        .optionsContent {
            flex: 1;
            min-height: 0;
            padding: 14px;
            border-radius: 0 var(--angled-radius) 0 var(--angled-radius);
            background: rgba(0, 0, 0, 0.28);
            border: 1px solid rgba(255, 255, 255, 0.06);
        }
        .optionsScroll {
            height: 100%;
            overflow: auto;
            padding-right: 6px;
            scrollbar-width: thin;
            scrollbar-color: #f2d24b rgba(12, 12, 18, 0.6);
        }
        .optionsScroll::-webkit-scrollbar {
            width: 12px;
        }
        .optionsScroll::-webkit-scrollbar-track {
            background: rgba(12, 12, 18, 0.6);
            border-radius: 999px;
        }
        .optionsScroll::-webkit-scrollbar-thumb {
            background: #f2d24b;
            border-radius: 999px;
            border: 2px solid #d4af37;
        }
        .optionsPane {
            display: none;
        }
        .optionsPane.active {
            display: block;
        }
        .optionsGrid {
            display: grid;
            grid-template-columns: repeat(2, minmax(0, 1fr));
            gap: 20px;
        }
        .optionsColumn {
            display: flex;
            flex-direction: column;
            gap: 18px;
        }
        .controlSection {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .sectionTitle {
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 2px;
            color: rgba(255, 255, 255, 0.65);
        }
        .optionRow {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 14px;
        }
        .optionLabel {
            font-size: 0.95rem;
        }
        .optionField {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .valueTag {
            min-width: 42px;
            text-align: right;
            font-size: 0.85rem;
            color: rgba(255, 255, 255, 0.7);
        }
        .toggleSwitch {
            position: relative;
            width: 46px;
            height: 24px;
            border-radius: 999px;
            background: rgba(255, 255, 255, 0.15);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        .toggleSwitch::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #f6d36b;
            box-shadow: 0 0 8px rgba(246, 211, 107, 0.4);
        }
        .keyButton.muted {
            color: rgba(255, 255, 255, 0.45);
            border-color: rgba(255, 255, 255, 0.16);
            background: rgba(0, 0, 0, 0.35);
        }
        .optionsDivider {
            height: 1px;
            width: 100%;
            background: rgba(255, 255, 255, 0.08);
            margin: 4px 0 6px;
        }
        .optionsLanguage {
            padding: 6px 12px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background: rgba(0, 0, 0, 0.35);
            text-transform: uppercase;
            font-size: 0.75rem;
            letter-spacing: 1px;
        }
        @media (max-width: 860px) {
            .optionsShell {
                height: min(760px, 82vh);
            }
            .optionsGrid {
                grid-template-columns: 1fr;
            }
            .controlRow {
                grid-template-columns: 1fr 1fr;
            }
        }
        #inventoryOverlay {
            align-items: center;
            justify-content: center;
        }
        .inventoryWindow {
            width: min(980px, 88%);
            height: min(680px, 70vh);
            display: flex;
            gap: 18px;
            position: relative;
            overflow: visible;
        }
        .inventoryPanel {
            flex: 1;
            min-width: 0;
            display: flex;
            flex-direction: column;
            gap: 12px;
            padding: 16px 18px 18px;
            background: #2c2f33;
            border-radius: 0 var(--angled-radius) 0 var(--angled-radius);
            border: 1px solid rgba(255, 255, 255, 0.08);
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.35);
        }
        .inventoryHeader {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .inventoryTopBar {
            width: 100%;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 24px;
        }
        .inventoryTitle {
            display: flex;
            align-items: center;
            gap: 10px;
            text-transform: uppercase;
            font-weight: 600;
            letter-spacing: 4px;
            font-size: 1.15rem;
        }
        .inventoryTitle .inventoryIcon {
            width: 26px;
            height: 26px;
            object-fit: contain;
            display: block;
        }
        .inventorySearch {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 12px 6px 14px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.16);
            background: rgba(0, 0, 0, 0.35);
            min-width: 220px;
        }
        .inventorySearch input {
            background: transparent;
            border: none;
            color: #fff;
            outline: none;
            width: 100%;
            flex: 1;
            font-size: 0.9rem;
        }
        .inventorySearch input::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }
        .inventorySearch .searchIcon {
            width: 18px;
            height: 18px;
            object-fit: contain;
            display: block;
            opacity: 0.7;
        }
        .inventoryTabs {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
            text-transform: uppercase;
            font-size: 0.7rem;
            letter-spacing: 1px;
            padding: 6px 8px;
            background: rgba(0, 0, 0, 0.12);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.08);
        }
        .inventoryTab {
            position: relative;
            padding: 6px 18px 8px 22px;
            border-radius: 10px 10px 0 0;
            border: 1px solid rgba(255, 255, 255, 0.12);
            background: rgba(0, 0, 0, 0.18);
            color: rgba(255, 255, 255, 0.7);
            cursor: pointer;
            clip-path: polygon(0 100%, 100% 100%, calc(100% - 8px) 0, 8px 0);
        }
        .inventoryTab.active {
            color: #1b1b1b;
            border-color: rgba(255, 255, 255, 0.14);
            background: linear-gradient(180deg, #f6d36b, #e2b04c);
        }
        .inventoryTab::before {
            content: '';
            position: absolute;
            left: 6px;
            bottom: 6px;
            width: 7px;
            height: 7px;
            border-radius: 50%;
            background: var(--category-color, #777);
        }
        .inventoryTab.noDot::before {
            display: none;
        }
        #inventoryItems {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(78px, 1fr));
            gap: 8px;
            row-gap: 8px;
            column-gap: 8px;
            align-content: start;
            overflow: auto;
            flex: 1;
            min-height: 0;
            padding: 12px;
            background: rgba(0, 0, 0, 0.22);
            border-radius: 0 var(--angled-radius) 0 var(--angled-radius);
            scrollbar-width: thin;
            scrollbar-color: #f2d24b rgba(12, 12, 18, 0.6);
        }
        .menuPage::-webkit-scrollbar,
        #inventoryItems::-webkit-scrollbar {
            width: 12px;
        }
        .menuPage::-webkit-scrollbar-track,
        #inventoryItems::-webkit-scrollbar-track {
            background: rgba(12, 12, 18, 0.6);
            border-radius: 999px;
        }
        .menuPage::-webkit-scrollbar-thumb,
        #inventoryItems::-webkit-scrollbar-thumb {
            background: #f2d24b;
            border-radius: 999px;
            border: 2px solid #d4af37;
        }
        .inventoryItem {
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 0 var(--angled-radius) 0 var(--angled-radius);
            padding: 8px;
            text-align: center;
            background: rgba(42, 46, 51, 0.9);
            cursor: grab;
            aspect-ratio: 1 / 1;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 4px;
            position: relative;
            transition: border-color 0.15s ease, box-shadow 0.15s ease, transform 0.15s ease;
        }
        .inventoryItem:hover {
            border-color: rgba(255, 205, 92, 0.75);
            box-shadow: 0 0 0 1px rgba(255, 205, 92, 0.2);
            transform: translateY(-1px);
        }
        .inventoryItem.notDraggable {
            cursor: default;
        }
        .inventoryItem .categoryDot {
            position: absolute;
            left: 8px;
            bottom: 8px;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--category-color, #777);
        }
        .inventoryItem.noDot .categoryDot {
            display: none;
        }
        .inventoryItem:active {
            cursor: grabbing;
        }
        .inventoryItem span.icon {
            display: block;
            font-size: 1.2rem;
        }
        .inventoryDetails {
            width: 260px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            padding: 16px;
            background: #2c2f33;
            border-radius: 0 var(--angled-radius) 0 var(--angled-radius);
            border: 1px solid rgba(255, 255, 255, 0.08);
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.35);
            position: absolute;
            top: 0;
            left: calc(100% + 18px);
            height: 100%;
            --detail-color: #e08a2e;
        }
        .inventoryDetails.empty {
            display: none;
        }
        .inventoryDetails.empty .inventoryDetailBody {
            opacity: 0;
        }
        .inventoryDetails.empty .inventoryDetailPreview {
            opacity: 0;
        }
        .inventoryDetailBody {
            display: flex;
            flex-direction: column;
            gap: 10px;
            transition: opacity 0.2s ease;
        }
        .inventoryDetailPreview {
            height: 210px;
            border-radius: 0 var(--angled-radius) 0 var(--angled-radius);
            background: linear-gradient(145deg, rgba(255, 255, 255, 0.06), rgba(0, 0, 0, 0.25));
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 3.2rem;
        }
        .inventoryDetailName {
            font-weight: 600;
            letter-spacing: 1px;
        }
        .inventoryDetailAccent {
            height: 3px;
            width: 100%;
            border-radius: 999px;
            background: var(--detail-color);
        }
        .inventoryDetailStats {
            display: flex;
            flex-direction: column;
            gap: 8px;
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: rgba(255, 255, 255, 0.7);
        }
        .detailRow {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
        }
        .detailDots {
            display: flex;
            gap: 3px;
        }
        .detailDots span {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.15);
        }
        .detailDots span.active {
            background: var(--detail-color);
        }
        .inventoryDetailDescLabel {
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: rgba(255, 255, 255, 0.5);
        }
        .inventoryDetailDesc {
            font-size: 0.8rem;
            line-height: 1.4;
            color: rgba(255, 255, 255, 0.7);
            min-height: 48px;
        }
        #hotbar {
            position: fixed;
            bottom: 24px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 8px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            z-index: 8;
        }
        .hotbarSlot {
            width: 60px;
            height: 60px;
            border: 1px solid rgba(255, 255, 255, 0.25);
            border-radius: 0 var(--angled-radius) 0 var(--angled-radius);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 0.75rem;
            text-align: center;
            background: rgba(0, 0, 0, 0.35);
            transition: box-shadow 0.15s ease, border-color 0.15s ease;
        }
        .hotbarSlot.selected {
            border-color: #7fffd4;
            box-shadow: 0 0 12px rgba(127, 255, 212, 0.5);
        }
        .hotbarSlot .icon {
            font-size: 1.4rem;
            margin-bottom: 2px;
        }
        .hotbarSlot.dropTarget {
            border-color: #ffd966;
            background: rgba(255, 217, 102, 0.15);
        }
        .crosshair {
            position: fixed;
            top: 50%;
            left: 50%;
            width: 12px;
            height: 12px;
            margin-left: -6px;
            margin-top: -6px;
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.7);
            pointer-events: none;
            z-index: 8;
        }
        .breakProgress {
            position: fixed;
            top: 50%;
            left: 50%;
            width: 32px;
            height: 32px;
            margin-left: -16px;
            margin-top: -16px;
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.2);
            pointer-events: none;
            opacity: 0;
            transform: scale(0.9);
            transition: opacity 0.12s ease, transform 0.12s ease;
            background: conic-gradient(rgba(255, 196, 120, 0.9) 0deg, rgba(255, 196, 120, 0.1) 0deg);
            z-index: 7;
        }
        #chatPanel {
            position: fixed;
            left: 24px;
            bottom: 110px;
            width: min(360px, 70vw);
            display: flex;
            flex-direction: column;
            gap: 8px;
            pointer-events: none;
            z-index: 9;
        }
        #chatMessages {
            display: flex;
            flex-direction: column;
            gap: 6px;
            max-height: 180px;
            overflow: hidden;
        }
        .chatMessage {
            background: rgba(0, 0, 0, 0.55);
            border: 1px solid rgba(255, 255, 255, 0.18);
            border-radius: 10px;
            padding: 6px 10px;
            font-size: 0.85rem;
            color: rgba(255, 255, 255, 0.85);
        }
        #chatInputRow {
            display: flex;
            align-items: center;
            gap: 8px;
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid rgba(255, 255, 255, 0.22);
            border-radius: 12px;
            padding: 6px 10px;
            pointer-events: auto;
            opacity: 0;
            transform: translateY(6px);
            transition: opacity 0.15s ease, transform 0.15s ease;
        }
        #chatPanel.active #chatInputRow {
            opacity: 1;
            transform: translateY(0);
        }
        #chatPrompt {
            text-transform: uppercase;
            font-size: 0.7rem;
            letter-spacing: 1px;
            color: rgba(255, 255, 255, 0.6);
        }
        #chatInput {
            flex: 1;
            background: transparent;
            border: none;
            color: #fff;
            outline: none;
            font-size: 0.9rem;
        }
        .breakProgress.visible {
            opacity: 1;
            transform: scale(1);
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div class="crosshair"></div>
    <div class="breakProgress"></div>
    <div id="fallback" style="display:none;">WebGL is required for this game.</div>

    <div id="menuOverlay">
        <div class="menuPage active" data-page="main">
            <div class="pauseMenuCard">
                <div class="pauseMenuIcon"></div>
                <div class="pauseMenuButtons">
                    <button id="resumeBtn" class="pauseMenuButton primary">Resume</button>
                    <button id="videoBtn" class="pauseMenuButton">Invite Friend</button>
                    <button id="accessibilityBtn" class="pauseMenuButton">Options</button>
                    <button id="controlsBtn" class="pauseMenuButton">Exit</button>
                </div>
            </div>
        </div>
        <div class="menuPage" data-page="options">
            <div class="optionsShell">
                <div class="optionsTopBar">
                    <div class="optionsTopLeft">
                        <button class="backBtn optionsBackBtn" data-target="main">Back</button>
                        <div class="optionsKeyHint">TAB</div>
                    </div>
                    <div class="optionsTitle">Options</div>
                    <div class="optionsTopRight">
                        <button id="optionsApplyBtn" class="optionsActionBtn primary">Apply</button>
                        <button id="optionsDefaultBtn" class="optionsActionBtn">Default</button>
                    </div>
                </div>
                <div class="optionsTabs">
                    <button class="optionsTab active" data-tab="gameplay">Gameplay</button>
                    <button class="optionsTab" data-tab="controls">Controls</button>
                    <button class="optionsTab" data-tab="audio">Audio</button>
                    <button class="optionsTab" data-tab="display">Display</button>
                    <button class="optionsTab" data-tab="graphics">Graphics</button>
                </div>
                <div class="optionsContent">
                    <div class="optionsScroll">
                        <div class="optionsPane active" data-tab-panel="gameplay"></div>
                        <div class="optionsPane" data-tab-panel="controls">
                            <div class="optionsGrid">
                                <div class="optionsColumn">
                                    <div class="controlSection">
                                        <div class="sectionTitle">Movement</div>
                                        <div class="optionRow">
                                            <div class="optionLabel">Inverted Y Axis</div>
                                            <div class="optionField">
                                                <div class="toggleSwitch" aria-hidden="true"></div>
                                            </div>
                                        </div>
                                        <div class="optionRow">
                                            <div class="optionLabel">Aim Sensitivity</div>
                                            <div class="optionField" style="flex:1;">
                                                <input id="aimSensitivitySlider" type="range" min="10" max="200" value="100">
                                                <div class="valueTag" id="aimSensitivityValue">100</div>
                                            </div>
                                        </div>
                                        <div class="optionRow">
                                            <div class="optionLabel">Flight Speed</div>
                                            <div class="optionField">
                                                <button id="flightSpeedBtn" type="button" class="keyButton">Normal</button>
                                            </div>
                                        </div>
                                        <div class="controlRow">
                                            <div class="controlLabel">Move Forward</div>
                                            <div class="keyButton">W</div>
                                            <div class="keyButton muted">Not Set</div>
                                        </div>
                                        <div class="controlRow">
                                            <div class="controlLabel">Move Backward</div>
                                            <div class="keyButton">S</div>
                                            <div class="keyButton muted">Not Set</div>
                                        </div>
                                        <div class="controlRow">
                                            <div class="controlLabel">Move Left</div>
                                            <div class="keyButton">A</div>
                                            <div class="keyButton muted">Not Set</div>
                                        </div>
                                        <div class="controlRow">
                                            <div class="controlLabel">Move Right</div>
                                            <div class="keyButton">D</div>
                                            <div class="keyButton muted">Not Set</div>
                                        </div>
                                        <div class="controlRow">
                                            <div class="controlLabel">Jump</div>
                                            <div class="keyButton">Space</div>
                                            <div class="keyButton muted">Not Set</div>
                                        </div>
                                        <div class="controlRow">
                                            <div class="controlLabel">Crouch</div>
                                            <div class="keyButton">Ctrl</div>
                                            <div class="keyButton muted">Not Set</div>
                                        </div>
                                        <div class="controlRow">
                                            <div class="controlLabel">Sprint</div>
                                            <div class="keyButton">Shift</div>
                                            <div class="keyButton muted">Not Set</div>
                                        </div>
                                    </div>
                                    <div class="controlSection">
                                        <div class="sectionTitle">Hotbar</div>
                                        <div class="controlRow">
                                            <div class="controlLabel">Next Hotbar Item</div>
                                            <div class="keyButton">Scroll Down</div>
                                            <div class="keyButton muted">Not Set</div>
                                        </div>
                                        <div class="controlRow">
                                            <div class="controlLabel">Previous Hotbar Item</div>
                                            <div class="keyButton">Scroll Up</div>
                                            <div class="keyButton muted">Not Set</div>
                                        </div>
                                        <div class="controlRow">
                                            <div class="controlLabel">Hotbar Item 1</div>
                                            <div class="keyButton">1</div>
                                            <div class="keyButton muted">Not Set</div>
                                        </div>
                                        <div class="controlRow">
                                            <div class="controlLabel">Hotbar Item 2</div>
                                            <div class="keyButton">2</div>
                                            <div class="keyButton muted">Not Set</div>
                                        </div>
                                        <div class="controlRow">
                                            <div class="controlLabel">Hotbar Item 3</div>
                                            <div class="keyButton">3</div>
                                            <div class="keyButton muted">Not Set</div>
                                        </div>
                                        <div class="controlRow">
                                            <div class="controlLabel">Hotbar Item 4</div>
                                            <div class="keyButton">4</div>
                                            <div class="keyButton muted">Not Set</div>
                                        </div>
                                        <div class="controlRow">
                                            <div class="controlLabel">Hotbar Item 5</div>
                                            <div class="keyButton">5</div>
                                            <div class="keyButton muted">Not Set</div>
                                        </div>
                                        <div class="controlRow">
                                            <div class="controlLabel">Hotbar Item 6</div>
                                            <div class="keyButton">6</div>
                                            <div class="keyButton muted">Not Set</div>
                                        </div>
                                        <div class="controlRow">
                                            <div class="controlLabel">Hotbar Item 7</div>
                                            <div class="keyButton">7</div>
                                            <div class="keyButton muted">Not Set</div>
                                        </div>
                                        <div class="controlRow">
                                            <div class="controlLabel">Hotbar Item 8</div>
                                            <div class="keyButton">8</div>
                                            <div class="keyButton muted">Not Set</div>
                                        </div>
                                        <div class="controlRow">
                                            <div class="controlLabel">Hotbar Item 9</div>
                                            <div class="keyButton">9</div>
                                            <div class="keyButton muted">Not Set</div>
                                        </div>
                                        <div class="controlRow">
                                            <div class="controlLabel">Hotbar Item 10</div>
                                            <div class="keyButton">0</div>
                                            <div class="keyButton muted">Not Set</div>
                                        </div>
                                    </div>
                                </div>
                                <div class="optionsColumn">
                                    <div class="controlSection">
                                        <div class="sectionTitle">Gameplay</div>
                                        <div class="controlRow">
                                            <div class="controlLabel">Build / Primary</div>
                                            <div class="keyButton">Mouse 1</div>
                                            <div class="keyButton muted">Not Set</div>
                                        </div>
                                        <div class="controlRow">
                                            <div class="controlLabel">Remove / Secondary</div>
                                            <div class="keyButton">Mouse 2</div>
                                            <div class="keyButton muted">Not Set</div>
                                        </div>
                                        <div class="controlRow">
                                            <div class="controlLabel">Use</div>
                                            <div class="keyButton">E</div>
                                            <div class="keyButton">Mouse 3</div>
                                        </div>
                                        <div class="controlRow">
                                            <div class="controlLabel">Upgrade</div>
                                            <div class="keyButton">U</div>
                                            <div class="keyButton muted">Not Set</div>
                                        </div>
                                        <div class="controlRow">
                                            <div class="controlLabel">Backpack</div>
                                            <div class="keyButton">I</div>
                                            <div class="keyButton">B</div>
                                        </div>
                                        <div class="controlRow">
                                            <div class="controlLabel">Logbook</div>
                                            <div class="keyButton">L</div>
                                            <div class="keyButton muted">Not Set</div>
                                        </div>
                                        <div class="controlRow">
                                            <div class="controlLabel">Next Rotation</div>
                                            <div class="keyButton">Q</div>
                                            <div class="keyButton muted">Not Set</div>
                                        </div>
                                        <div class="controlRow">
                                            <div class="controlLabel">Previous Rotation</div>
                                            <div class="keyButton">Shift + Q</div>
                                            <div class="keyButton muted">Not Set</div>
                                        </div>
                                        <div class="controlRow">
                                            <div class="controlLabel">Lift Up</div>
                                            <div class="keyButton">Arrow Up</div>
                                            <div class="keyButton muted">Not Set</div>
                                        </div>
                                        <div class="controlRow">
                                            <div class="controlLabel">Lift Down</div>
                                            <div class="keyButton">Arrow Down</div>
                                            <div class="keyButton muted">Not Set</div>
                                        </div>
                                        <div class="controlRow">
                                            <div class="controlLabel">Force Build</div>
                                            <div class="keyButton">F</div>
                                            <div class="keyButton muted">Not Set</div>
                                        </div>
                                        <div class="controlRow">
                                            <div class="controlLabel">Reload</div>
                                            <div class="keyButton">R</div>
                                            <div class="keyButton muted">Not Set</div>
                                        </div>
                                    </div>
                                    <div class="controlSection">
                                        <div class="sectionTitle">Miscellaneous</div>
                                        <div class="controlRow">
                                            <div class="controlLabel">Zoom In</div>
                                            <div class="keyButton">X</div>
                                            <div class="keyButton">Alt + Scroll Up</div>
                                        </div>
                                        <div class="controlRow">
                                            <div class="controlLabel">Zoom Out</div>
                                            <div class="keyButton">C</div>
                                            <div class="keyButton">Alt + Scroll Down</div>
                                        </div>
                                        <div class="controlRow">
                                            <div class="controlLabel">Chat</div>
                                            <div class="keyButton">T</div>
                                            <div class="keyButton">Enter</div>
                                        </div>
                                    </div>
                                    <div class="controlSection">
                                        <div class="sectionTitle">Creative</div>
                                        <div class="controlRow">
                                            <div class="controlLabel">Next Hotbar</div>
                                            <div class="keyButton">Alt + Q</div>
                                            <div class="keyButton muted">Not Set</div>
                                        </div>
                                        <div class="controlRow">
                                            <div class="controlLabel">Previous Hotbar</div>
                                            <div class="keyButton">Alt + Shift + Q</div>
                                            <div class="keyButton muted">Not Set</div>
                                        </div>
                                        <div class="controlRow">
                                            <div class="controlLabel">Select Hotbar 1</div>
                                            <div class="keyButton">F1</div>
                                            <div class="keyButton muted">Not Set</div>
                                        </div>
                                        <div class="controlRow">
                                            <div class="controlLabel">Select Hotbar 2</div>
                                            <div class="keyButton">F2</div>
                                            <div class="keyButton muted">Not Set</div>
                                        </div>
                                        <div class="controlRow">
                                            <div class="controlLabel">Select Hotbar 3</div>
                                            <div class="keyButton">F3</div>
                                            <div class="keyButton muted">Not Set</div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="optionsPane" data-tab-panel="audio">
                            <div class="controlSection">
                                <div class="sectionTitle">Audio</div>
                                <div class="optionRow">
                                    <div class="optionLabel">Master Volume</div>
                                    <div class="optionField" style="flex:1;">
                                        <input type="range" min="0" max="100" value="80">
                                        <div class="valueTag">80</div>
                                    </div>
                                </div>
                                <div class="optionRow">
                                    <div class="optionLabel">Ambient</div>
                                    <div class="optionField" style="flex:1;">
                                        <input type="range" min="0" max="100" value="65">
                                        <div class="valueTag">65</div>
                                    </div>
                                </div>
                                <div class="optionRow">
                                    <div class="optionLabel">Music</div>
                                    <div class="optionField" style="flex:1;">
                                        <input type="range" min="0" max="100" value="50">
                                        <div class="valueTag">50</div>
                                    </div>
                                </div>
                                <div class="optionRow">
                                    <div class="optionLabel">Effect</div>
                                    <div class="optionField" style="flex:1;">
                                        <input type="range" min="0" max="100" value="70">
                                        <div class="valueTag">70</div>
                                    </div>
                                </div>
                                <div class="optionRow">
                                    <div class="optionLabel">GUI</div>
                                    <div class="optionField" style="flex:1;">
                                        <input type="range" min="0" max="100" value="75">
                                        <div class="valueTag">75</div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="optionsPane" data-tab-panel="display">
                            <div class="controlSection">
                                <div class="sectionTitle">Display</div>
                                <div class="optionRow">
                                    <div class="optionLabel">Field of View</div>
                                    <div class="optionField" style="flex:1;">
                                        <input id="displayFovSlider" type="range" min="45" max="90" value="70">
                                        <div class="valueTag" id="displayFovValue">70</div>
                                    </div>
                                </div>
                                <div class="optionRow">
                                    <div class="optionLabel">Brightness</div>
                                    <div class="optionField" style="flex:1;">
                                        <input type="range" min="-100" max="100" value="0">
                                        <div class="valueTag">0</div>
                                    </div>
                                </div>
                                <div class="optionRow">
                                    <div class="optionLabel">Language</div>
                                    <div class="optionField">
                                        <div class="optionsLanguage">English</div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="optionsPane" data-tab-panel="graphics"></div>
                    </div>
                </div>
            </div>
        </div>
        <div class="menuPage" data-page="video">
            <h2>Video Settings</h2>
            <div class="sliderRow">
                <label for="fovSlider">Field of View (<span id="fovValue">70&deg;</span>)</label>
                <input type="range" id="fovSlider" min="30" max="110" value="70">
            </div>
            <small>Fine-tune camera FOV to match your preference.</small>
            <div class="menuBackBar">
                <button class="backBtn" data-target="main">Tab</button>
            </div>
        </div>
        <div class="menuPage" data-page="accessibility">
            <h2>Accessibility</h2>
            <div class="sliderRow">
                <label for="doubleTapModeBtn">Flight toggling double-tap timing</label>
                <button id="doubleTapModeBtn" type="button">fast (50-150ms)</button>
            </div>
            <div class="menuBackBar">
                <button class="backBtn" data-target="main">Tab</button>
            </div>
        </div>
        <div class="menuPage" data-page="controls">
            <h2>Controls</h2>
            <p>Click a slot, then hold up to 3 keys. Release to save. Press Tab while assigning to clear.</p>
            <div class="controlsTable" id="controlsList"></div>
            <div class="menuBackBar">
                <button class="backBtn" data-target="main">Tab</button>
            </div>
        </div>
    </div>

    <div id="inventoryOverlay">
        <div class="inventoryWindow">
            <div class="inventoryPanel">
                <div class="inventoryHeader">
                    <div class="inventoryTopBar">
                        <div class="inventoryTitle">
                            <img class="inventoryIcon" src="Data/Gui/Resolutions/2560x1440/Inventory/gui_inventory_icon_backpack.png" alt="Backpack">
                            <span>Backpack</span>
                        </div>
                        <label class="inventorySearch">
                            <input id="inventorySearchInput" type="text" placeholder="Search" autocomplete="off">
                            <img class="searchIcon" src="Data/Gui/Editor/ed_icon_search.png" alt="Search">
                        </label>
                    </div>
                    <div class="inventoryTabs" id="inventoryTabs"></div>
                </div>
                <div id="inventoryItems"></div>
            </div>
            <div class="inventoryDetails empty" id="inventoryDetails">
                <div class="inventoryDetailPreview" id="inventoryDetailPreview">
                    <span id="inventoryDetailIcon"></span>
                </div>
                <div class="inventoryDetailBody">
                    <div class="inventoryDetailName" id="inventoryDetailName"></div>
                    <div class="inventoryDetailAccent"></div>
                    <div class="inventoryDetailStats" id="inventoryDetailStats"></div>
                    <div class="inventoryDetailDescLabel">Description</div>
                    <div class="inventoryDetailDesc" id="inventoryDetailDesc"></div>
                </div>
            </div>
        </div>
    </div>

    <div id="hotbar"></div>
    <div id="chatPanel">
        <div id="chatMessages"></div>
        <div id="chatInputRow">
            <div id="chatPrompt">Chat</div>
            <input id="chatInput" type="text" maxlength="140" autocomplete="off">
        </div>
    </div>

    <script type="module">
        import * as THREE from './lib/three.module.js';
        import { FBXLoader } from './lib/FBXloader.js';
        (function () {
            const canvas = document.getElementById('gameCanvas');
            const fallback = document.getElementById('fallback');
            const menuOverlay = document.getElementById('menuOverlay');
            const inventoryOverlay = document.getElementById('inventoryOverlay');
            const resumeBtn = document.getElementById('resumeBtn');
            const videoBtn = document.getElementById('videoBtn');
            const controlsBtn = document.getElementById('controlsBtn');
            const accessibilityBtn = document.getElementById('accessibilityBtn');
            const optionsVideoBtn = document.getElementById('optionsVideoBtn');
            const optionsAccessibilityBtn = document.getElementById('optionsAccessibilityBtn');
            const optionsControlsBtn = document.getElementById('optionsControlsBtn');
            const optionsApplyBtn = document.getElementById('optionsApplyBtn');
            const optionsDefaultBtn = document.getElementById('optionsDefaultBtn');
            const optionsTabButtons = Array.from(document.querySelectorAll('.optionsTab'));
            const optionsTabPanels = Array.from(document.querySelectorAll('.optionsPane'));
            const aimSensitivitySlider = document.getElementById('aimSensitivitySlider');
            const aimSensitivityValue = document.getElementById('aimSensitivityValue');
            const flightSpeedBtn = document.getElementById('flightSpeedBtn');
            const displayFovSlider = document.getElementById('displayFovSlider');
            const displayFovValue = document.getElementById('displayFovValue');
            const fovSlider = document.getElementById('fovSlider');
            const fovValue = document.getElementById('fovValue');
            const controlsList = document.getElementById('controlsList');
            const inventoryItems = document.getElementById('inventoryItems');
            const inventoryTabs = document.getElementById('inventoryTabs');
            const inventorySearchInput = document.getElementById('inventorySearchInput');
            const inventoryDetails = document.getElementById('inventoryDetails');
            const inventoryDetailIcon = document.getElementById('inventoryDetailIcon');
            const inventoryDetailName = document.getElementById('inventoryDetailName');
            const inventoryDetailDesc = document.getElementById('inventoryDetailDesc');
            const inventoryDetailStats = document.getElementById('inventoryDetailStats');
            const closeInventoryBtn = document.getElementById('closeInventoryBtn');
            const hotbar = document.getElementById('hotbar');
            const chatPanel = document.getElementById('chatPanel');
            const chatMessages = document.getElementById('chatMessages');
            const chatInput = document.getElementById('chatInput');
            const crosshair = document.querySelector('.crosshair');
            const breakProgress = document.querySelector('.breakProgress');
            const doubleTapModeBtn = document.getElementById('doubleTapModeBtn');
            const gl = canvas.getContext('webgl');
            const uintElementExt = gl ? gl.getExtension('OES_element_index_uint') : null;
            const DEFAULT_AIM_SLIDER = 100;
            const DEFAULT_FOV = 70;
            const DEFAULT_FLIGHT_SPEED = 'normal';
            const AIM_SENS_MIN = 0.0005;
            const AIM_SENS_MAX = 0.01;
            const camera = {
                yaw: 0,
                pitch: 0
            };
            const settings = {
                aimSensitivity: AIM_SENS_MIN + ((DEFAULT_AIM_SLIDER - 10) / 190) * (AIM_SENS_MAX - AIM_SENS_MIN),
                fov: DEFAULT_FOV,
                flightSpeed: DEFAULT_FLIGHT_SPEED,
                doubleTapMin: 50,
                doubleTapMax: 150
            };
            const doubleTapPresets = [
                { id: 'fast', label: 'fast', min: 50, max: 150 },
                { id: 'normal', label: 'normal', min: 150, max: 200 },
                { id: 'slow', label: 'slow', min: 200, max: 300 }
            ];
            let doubleTapPresetIndex = 0;
            const BLOCK_SCALE = 1 / 3;
            const INV_BLOCK_SCALE = 1 / BLOCK_SCALE;
            const MAX_DRAG_DISTANCE = 16;
            const MAX_DRAG_EXTENT = MAX_DRAG_DISTANCE - 1;
            let DRAGGABLE_ITEMS = new Set();
            const AXIS_MODES = [
                { id: 'XZ', axes: [0, 2], locked: 1, forward: [0, 1, 0], up: [0, 0, 1] },
                { id: 'XY', axes: [0, 1], locked: 2, forward: [0, 0, 1], up: [0, 1, 0] },
                { id: 'YZ', axes: [1, 2], locked: 0, forward: [1, 0, 0], up: [0, 1, 0] }
            ];
            const PREVIEW_STYLES = {
                hover: { fill: [1, 1, 1], outline: [1, 1, 1] },
                place: { fill: [0.98, 0.87, 0.35], outline: [1, 0.8, 0.2] },
                break: { fill: [0.93, 0.3, 0.3], outline: [0.85, 0.2, 0.2] }
            };
            const PREVIEW_FILL_ALPHA = 0.35;
            const PREVIEW_OUTLINE_ALPHA = 0.9;
            const BREAK_HOLD_DURATION = 500;
            const PULSE_DISTANCE_BLOCKS = 10;
            const PULSE_IMPULSE = 6;
            const PULSE_ANGULAR_SCALE = 0.4;
            const GRAVITY = [0, -9.81, 0];
            const SOLVER_ITERATIONS = 15;
            const BAUMGARTE_BIAS = 0.2;
            const CONTACT_SLOP = BLOCK_SCALE * 0.02;
            const CONTACT_MERGE_EPS = BLOCK_SCALE * 0.05;
            const RESTITUTION_VELOCITY_SLOP = 0.5;
            const SLEEP_LINEAR_EPS = 0.05;
            const SLEEP_ANGULAR_EPS = 0.05;
            const SLEEP_FRAMES = 30;
            const GROUND_STATIC_FRICTION = 1;
            const GROUND_DYNAMIC_FRICTION = 0.8;
            const GROUND_RESTITUTION = 0.05;
            const ORIENTATIONS = (() => {
                const axes = [
                    [1, 0, 0], [-1, 0, 0],
                    [0, 1, 0], [0, -1, 0],
                    [0, 0, 1], [0, 0, -1]
                ];
                const list = [];
                axes.forEach(fwd => {
                    axes.forEach(up => {
                        if (fwd[0] * up[0] + fwd[1] * up[1] + fwd[2] * up[2]) return;
                        list.push({ forward: fwd, up });
                    });
                });
                return list;
            })();
            const objectOrientationIndex = new Map();

            if (!gl) {
                fallback.style.display = 'block';
                return;
            }
            const supportsDerivatives = !!gl.getExtension('OES_standard_derivatives');
            const GAME_DATA_ROOT = 'Data';
            const BLOCK_ICON = '\u{1F9F1}';
            let itemsCatalog = [];
            let itemsById = new Map();
            let inventoryState = {};
            let blockDefinitions = new Map();
            let blockTextures = new Map();
            const objectDefinitions = new Map();
            const blockTextureStatus = new Map();
            const canisterMeshCache = new Map();
            const worldObjects = [];
            const PHYSICS_STATE = {
                ACTIVE: 'active',
                REST: 'rest'
            };
            let supportDirty = false;

            function wakeWorldObject(obj) {
                if (!obj) return;
                obj.physicsState = PHYSICS_STATE.ACTIVE;
                obj.sleepCounter = 0;
            }

            function restWorldObject(obj) {
                if (!obj) return;
                obj.physicsState = PHYSICS_STATE.REST;
                obj.velocity = [0, 0, 0];
                obj.angularVelocity = [0, 0, 0];
                obj.sleepCounter = 0;
            }

            function applyImpulseToObject(obj, linearImpulse, angularImpulse) {
                if (!obj) return;
                wakeWorldObject(obj);
                if (linearImpulse) {
                    obj.velocity[0] += linearImpulse[0] * obj.invMass;
                    obj.velocity[1] += linearImpulse[1] * obj.invMass;
                    obj.velocity[2] += linearImpulse[2] * obj.invMass;
                }
                if (angularImpulse) {
                    const invInertia = obj.invInertiaWorld || obj.invInertiaLocal;
                    const deltaW = mat3MultiplyVec(invInertia, angularImpulse);
                    obj.angularVelocity[0] += deltaW[0];
                    obj.angularVelocity[1] += deltaW[1];
                    obj.angularVelocity[2] += deltaW[2];
                }
            }

            function resolveGameDataPath(path) {
                if (!path) return null;
                return path.replace(/^\$GAME_DATA\//, `${GAME_DATA_ROOT}/`);
            }

            function hexToRgb(hex) {
                const clean = (hex || '').replace('#', '').trim();
                if (clean.length === 3) {
                    const r = parseInt(clean[0] + clean[0], 16);
                    const g = parseInt(clean[1] + clean[1], 16);
                    const b = parseInt(clean[2] + clean[2], 16);
                    return [r / 255, g / 255, b / 255];
                }
                if (clean.length === 6) {
                    const r = parseInt(clean.slice(0, 2), 16);
                    const g = parseInt(clean.slice(2, 4), 16);
                    const b = parseInt(clean.slice(4, 6), 16);
                    return [r / 255, g / 255, b / 255];
                }
                return [0.7, 0.7, 0.7];
            }

            function formatBlockName(name) {
                if (!name) return 'Block';
                const raw = name.replace(/^blk_/, '').replace(/_/g, ' ');
                return raw.replace(/\b\w/g, char => char.toUpperCase());
            }

            function buildBlockStats(block) {
                const ratings = block.ratings || {};
                const clampDots = value => Math.max(0, Math.min(5, Math.round(value || 0)));
                return [
                    { label: 'Weight', dots: clampDots(ratings.density) },
                    { label: 'Durability', dots: clampDots(ratings.durability) },
                    { label: 'Friction', dots: clampDots(ratings.friction) },
                    { label: 'Buoyancy', dots: clampDots(ratings.buoyancy) },
                    { label: 'Flammable', value: block.flammable ? 'Yes' : 'No' }
                ];
            }

            function rebuildItemIndex() {
                itemsById = new Map();
                itemsCatalog.forEach(item => itemsById.set(item.id, item));
            }

            async function loadInteractiveCanisters() {
                try {
                    const response = await fetch(`${GAME_DATA_ROOT}/Objects/Database/ShapeSets/interactive.json`);
                    if (!response.ok) throw new Error(`Failed to load interactive.json (${response.status})`);
                    const data = await response.json();
                    const entries = (data.partList || []).filter(part =>
                        part.name === 'obj_interactive_propanetank_small' ||
                        part.name === 'obj_interactive_propanetank_large'
                    );
                    const makeTexturePaths = base => ({
                        dif: `${GAME_DATA_ROOT}/Objects/Textures/interactive/${base}_dif.tga`,
                        asg: `${GAME_DATA_ROOT}/Objects/Textures/interactive/${base}_asg.tga`,
                        nor: `${GAME_DATA_ROOT}/Objects/Textures/interactive/${base}_nor.tga`
                    });
                    const loadRendMeta = async base => {
                        const rendPath = `${GAME_DATA_ROOT}/Objects/Renderable/Interactive/${base}.rend`;
                        try {
                            const rendResp = await fetch(rendPath);
                            if (!rendResp.ok) throw new Error(`rend load failed (${rendResp.status})`);
                            const rend = await rendResp.json();
                            const lod0 = rend && rend.lodList && rend.lodList[0];
                            if (!lod0) return {};
                            return {
                                meshPath: resolveGameDataPath(lod0.mesh),
                                posePath: resolveGameDataPath(lod0.pose0)
                            };
                        } catch (err) {
                            console.warn('Failed to read rend meta:', rendPath, err);
                            return {};
                        }
                    };
                    const newItems = await Promise.all(entries.map(async part => {
                        const base = part.name;
                        const textures = makeTexturePaths(base);
                        const sizeBox = part.box || { x: 1, y: 1, z: 1 };
                        const isLarge = base.includes('large');
                        const explosionRadius = (part.scripted && part.scripted.data && part.scripted.data.destructionRadius) || (isLarge ? 4 : 2);
                        const explosionPower = (part.scripted && part.scripted.data && part.scripted.data.destructionLevel) || (isLarge ? 14 : 7);
                        const rendMeta = await loadRendMeta(base);
                        const item = {
                            id: part.uuid,
                            name: isLarge ? 'Large Canister' : 'Canister',
                            icon: '⛽',
                            color: hexToRgb(part.color || 'cb0a00'),
                            category: 'interactive',
                            description: 'Explosive canister.',
                            stats: buildBlockStats(part),
                            texturePath: textures.dif,
                            normalPath: textures.nor,
                            asgPath: textures.asg,
                            meshPath: rendMeta.meshPath,
                            posePath: rendMeta.posePath,
                            tiling: 1,
                            raw: part,
                            size: { x: sizeBox.x || 1, y: sizeBox.y || 1, z: sizeBox.z || 1 },
                            isCanister: true,
                            isMultiBlock: true,
                            explosionRadius,
                            explosionPower
                        };
                        objectDefinitions.set(item.id, {
                            size: item.size,
                            texturePath: item.texturePath,
                            normalPath: item.normalPath,
                            asgPath: item.asgPath,
                            meshPath: item.meshPath,
                            posePath: item.posePath,
                            isMultiBlock: true,
                            explosionRadius,
                            explosionPower
                        });
                        return item;
                    }));
                    return newItems;
                } catch (error) {
                    console.error('Failed to load interactive canisters:', error);
                    return [];
                }
            }

            async function loadBlocksCatalog() {
                try {
                    const response = await fetch(`${GAME_DATA_ROOT}/Objects/Database/ShapeSets/blocks.json`);
                    if (!response.ok) throw new Error(`Failed to load blocks.json (${response.status})`);
                    const data = await response.json();
                    const blocks = (data.blockList || []).map(block => {
                        const difPath = resolveGameDataPath(block.dif);
                        const norPath = resolveGameDataPath(block.nor);
                        const asgPath = resolveGameDataPath(block.asg);
                        const entry = {
                            id: block.uuid,
                            name: formatBlockName(block.name),
                            icon: BLOCK_ICON,
                            color: hexToRgb(block.color),
                            category: 'blocks',
                            description: `Material: ${block.physicsMaterial || 'Unknown'}`,
                            stats: buildBlockStats(block),
                            texturePath: difPath,
                            normalPath: norPath,
                            asgPath: asgPath,
                            opacity: block.glass ? 0.35 : 1,
                            isGlass: !!block.glass,
                            isSeeThrough: !!block.glass,
                            tiling: block.tiling || 1,
                            raw: block
                        };
                        blockDefinitions.set(entry.id, entry);
                        return entry;
                    });
                    itemsCatalog = blocks.concat([
                        {
                            id: 'flower',
                            name: 'Flower',
                            icon: '⛽',
                            color: [0.8, 0.3, 0.3],
                            category: 'parts',
                            description: 'Lightweight decorative item.',
                            stats: [
                                { label: 'Weight', dots: 1 },
                                { label: 'Durability', dots: 1 },
                                { label: 'Friction', dots: 1 },
                                { label: 'Buoyancy', dots: 4 },
                                { label: 'Flammable', value: 'Yes' }
                            ]
                        },
                        {
                            id: 'leaf',
                            name: 'Leaf',
                            icon: '⛽',
                            color: [0.2, 0.5, 0.2],
                            category: 'parts',
                            description: 'Organic material for mixes.',
                            stats: [
                                { label: 'Weight', dots: 1 },
                                { label: 'Durability', dots: 1 },
                                { label: 'Friction', dots: 2 },
                                { label: 'Buoyancy', dots: 4 },
                                { label: 'Flammable', value: 'Yes' }
                            ]
                        }
                    ]);
                    inventoryState = {};
                    blocks.forEach(block => {
                        inventoryState[block.id] = 64;
                    });
                    inventoryState.flower = 12;
                    inventoryState.leaf = 24;
                    DRAGGABLE_ITEMS = new Set(blocks.map(block => block.id));
                } catch (error) {
                    console.error('Failed to load block catalog:', error);
                }
            }

            const textureCache = new Map();

            function createSolidTexture(rgba) {
                const texture = gl.createTexture();
                gl.bindTexture(gl.TEXTURE_2D, texture);
                gl.texImage2D(
                    gl.TEXTURE_2D,
                    0,
                    gl.RGBA,
                    1,
                    1,
                    0,
                    gl.RGBA,
                    gl.UNSIGNED_BYTE,
                    new Uint8Array(rgba)
                );
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
                return texture;
            }

            function decodeTga(buffer) {
                const bytes = new Uint8Array(buffer);
                const idLength = bytes[0];
                const imageType = bytes[2];
                const width = bytes[12] | (bytes[13] << 8);
                const height = bytes[14] | (bytes[15] << 8);
                const bpp = bytes[16];
                const descriptor = bytes[17];
                const pixelSize = bpp / 8;
                const topOrigin = (descriptor & 0x20) !== 0;
                const offset = 18 + idLength;
                const pixelCount = width * height;
                const rgba = new Uint8Array(pixelCount * 4);
                if (imageType !== 2 && imageType !== 10) {
                    throw new Error(`Unsupported TGA type ${imageType}`);
                }

                let pixelIndex = 0;
                let ptr = offset;
                const writePixel = (index, r, g, b, a) => {
                    const x = index % width;
                    const y = Math.floor(index / width);
                    const destY = topOrigin ? y : (height - 1 - y);
                    const dest = (destY * width + x) * 4;
                    rgba[dest] = r;
                    rgba[dest + 1] = g;
                    rgba[dest + 2] = b;
                    rgba[dest + 3] = a;
                };

                const readPixel = () => {
                    const b = bytes[ptr++];
                    const g = bytes[ptr++];
                    const r = bytes[ptr++];
                    const a = pixelSize === 4 ? bytes[ptr++] : 255;
                    return [r, g, b, a];
                };

                if (imageType === 2) {
                    while (pixelIndex < pixelCount) {
                        const [r, g, b, a] = readPixel();
                        writePixel(pixelIndex, r, g, b, a);
                        pixelIndex += 1;
                    }
                } else {
                    while (pixelIndex < pixelCount) {
                        const packet = bytes[ptr++];
                        const count = (packet & 0x7f) + 1;
                        if (packet & 0x80) {
                            const [r, g, b, a] = readPixel();
                            for (let i = 0; i < count; i++) {
                                writePixel(pixelIndex, r, g, b, a);
                                pixelIndex += 1;
                            }
                        } else {
                            for (let i = 0; i < count; i++) {
                                const [r, g, b, a] = readPixel();
                                writePixel(pixelIndex, r, g, b, a);
                                pixelIndex += 1;
                            }
                        }
                    }
                }
                return { width, height, data: rgba };
            }

            function createTextureFromDecodedTga(decoded, wrapMode = gl.REPEAT) {
                const texture = gl.createTexture();
                gl.bindTexture(gl.TEXTURE_2D, texture);
                gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
                gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
                gl.texImage2D(
                    gl.TEXTURE_2D,
                    0,
                    gl.RGBA,
                    decoded.width,
                    decoded.height,
                    0,
                    gl.RGBA,
                    gl.UNSIGNED_BYTE,
                    decoded.data
                );
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, wrapMode);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, wrapMode);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                gl.generateMipmap(gl.TEXTURE_2D);
                return texture;
            }

            async function loadTgaTexture(path, wrapMode = gl.REPEAT) {
                if (!path) return null;
                if (textureCache.has(path)) {
                    return textureCache.get(path);
                }
                const promise = (async () => {
                    const response = await fetch(path);
                    if (!response.ok) {
                        throw new Error(`Failed to load texture ${path} (${response.status})`);
                    }
                    const buffer = await response.arrayBuffer();
                    const decoded = decodeTga(buffer);
                    return createTextureFromDecodedTga(decoded, wrapMode);
                })().catch(error => {
                    console.warn('Texture load failed:', path, error);
                    return null;
                });
                textureCache.set(path, promise);
                return promise;
            }

            async function loadBlockTextures() {
                const blocks = itemsCatalog.filter(item => item.category === 'blocks');
                await Promise.all(blocks.map(async block => {
                    const albedo = block.texturePath ? await loadTgaTexture(block.texturePath, gl.REPEAT) : null;
                    const normal = block.normalPath ? await loadTgaTexture(block.normalPath, gl.REPEAT) : null;
                    const asg = block.asgPath ? await loadTgaTexture(block.asgPath, gl.REPEAT) : null;
                    if (albedo || normal || asg) {
                        blockTextures.set(block.id, { albedo, normal, asg });
                        blockTextureStatus.set(block.id, 'ready');
                    }
                }));
            }

            async function loadObjectTextures() {
                const entries = Array.from(objectDefinitions.entries());
                await Promise.all(entries.map(async ([id, def]) => {
                    const albedo = def.texturePath ? await loadTgaTexture(def.texturePath, gl.CLAMP_TO_EDGE) : null;
                    const normal = def.normalPath ? await loadTgaTexture(def.normalPath, gl.CLAMP_TO_EDGE) : null;
                    const asg = def.asgPath ? await loadTgaTexture(def.asgPath, gl.CLAMP_TO_EDGE) : null;
                    if (albedo || normal || asg) {
                        blockTextures.set(id, { albedo, normal, asg });
                        blockTextureStatus.set(id, 'ready');
                    }
                }));
            }
            const INVENTORY_CATEGORIES = [
                { id: 'all', label: 'All', color: '#8d949b' },
                { id: 'tools', label: 'Tools', color: '#f2d24b' },
                { id: 'blocks', label: 'Blocks', color: '#6ab7ff' },
                { id: 'interactive', label: 'Interactive', color: '#f7a23b' },
                { id: 'parts', label: 'Parts', color: '#7ee081' },
                { id: 'consumable', label: 'Consumable', color: '#d78bd6' },
                { id: 'modParts', label: 'Mod Parts' }
            ];
            const CATEGORY_ORDER = ['tools', 'blocks', 'interactive', 'parts', 'consumable', 'modParts'];
            let activeInventoryCategory = 'all';
            let inventorySearchQuery = '';

            const actionDefinitions = [
                { id: 'moveForward', label: 'Move Forward', defaults: ['KeyW', null] },
                { id: 'moveBackward', label: 'Move Backward', defaults: ['KeyS', null] },
                { id: 'moveLeft', label: 'Move Left', defaults: ['KeyA', null] },
                { id: 'moveRight', label: 'Move Right', defaults: ['KeyD', null] },
                { id: 'jump', label: 'Jump', defaults: ['Space', null] },
                { id: 'crouch', label: 'Crouch', defaults: ['ControlLeft', null] },
                { id: 'sprint', label: 'Sprint', defaults: ['ShiftLeft', null] },
                { id: 'hotbarNext', label: 'Next Hotbar Item', defaults: ['WheelDown', null] },
                { id: 'hotbarPrev', label: 'Previous Hotbar Item', defaults: ['WheelUp', null] },
                { id: 'hotbar0', label: 'Hotbar Slot 1', defaults: ['Digit1', null] },
                { id: 'hotbar1', label: 'Hotbar Slot 2', defaults: ['Digit2', null] },
                { id: 'hotbar2', label: 'Hotbar Slot 3', defaults: ['Digit3', null] },
                { id: 'hotbar3', label: 'Hotbar Slot 4', defaults: ['Digit4', null] },
                { id: 'hotbar4', label: 'Hotbar Slot 5', defaults: ['Digit5', null] },
                { id: 'hotbar5', label: 'Hotbar Slot 6', defaults: ['Digit6', null] },
                { id: 'hotbar6', label: 'Hotbar Slot 7', defaults: ['Digit7', null] },
                { id: 'hotbar7', label: 'Hotbar Slot 8', defaults: ['Digit8', null] },
                { id: 'hotbar8', label: 'Hotbar Slot 9', defaults: ['Digit9', null] },
                { id: 'hotbar9', label: 'Hotbar Slot 10', defaults: ['Digit0', null] },
                { id: 'buildPrimary', label: 'Build / Primary', defaults: ['Mouse1', null] },
                { id: 'removeSecondary', label: 'Remove / Secondary', defaults: ['Mouse2', null] },
                { id: 'use', label: 'Use', defaults: ['KeyE', 'Mouse3'] },
                { id: 'upgrade', label: 'Upgrade', defaults: ['KeyU', null] },
                { id: 'openInventory', label: 'Backpack', defaults: ['KeyI', 'KeyB'] },
                { id: 'logbook', label: 'Logbook', defaults: ['KeyL', null] },
                { id: 'cycleAxis', label: 'Next Rotation', defaults: ['KeyQ', null] },
                { id: 'cycleAxisReverse', label: 'Previous Rotation', defaults: ['ShiftLeft+KeyQ', null] },
                { id: 'liftUp', label: 'Lift Up', defaults: ['ArrowUp', null] },
                { id: 'liftDown', label: 'Lift Down', defaults: ['ArrowDown', null] },
                { id: 'forceBuild', label: 'Force Build', defaults: ['KeyF', null] },
                { id: 'pulse', label: 'Pulse Impulse', defaults: ['KeyG', null] },
                { id: 'reload', label: 'Reload', defaults: ['KeyR', null] },
                { id: 'zoomIn', label: 'Zoom In', defaults: ['KeyX', 'AltLeft+WheelUp'] },
                { id: 'zoomOut', label: 'Zoom Out', defaults: ['KeyC', 'AltLeft+WheelDown'] },
                { id: 'chat', label: 'Chat', defaults: ['KeyT', 'Enter'] },
                { id: 'creativeNextHotbar', label: 'Next Hotbar', defaults: ['AltLeft+KeyQ', null] },
                { id: 'creativePrevHotbar', label: 'Previous Hotbar', defaults: ['AltLeft+ShiftLeft+KeyQ', null] },
                { id: 'creativeHotbar1', label: 'Select Hotbar 1', defaults: ['F1', null] },
                { id: 'creativeHotbar2', label: 'Select Hotbar 2', defaults: ['F2', null] },
                { id: 'creativeHotbar3', label: 'Select Hotbar 3', defaults: ['F3', null] }
            ];

            const keyBindings = {};
            actionDefinitions.forEach(def => {
                keyBindings[def.id] = [...def.defaults];
            });
            const MODIFIER_KEYS = new Set([
                'ShiftLeft', 'ShiftRight',
                'ControlLeft', 'ControlRight',
                'AltLeft', 'AltRight',
                'MetaLeft', 'MetaRight'
            ]);
            const MODIFIER_ORDER = [
                'ControlLeft', 'ControlRight',
                'ShiftLeft', 'ShiftRight',
                'AltLeft', 'AltRight',
                'MetaLeft', 'MetaRight'
            ];
            const MAX_COMBO_KEYS = 3;

            function getItemDef(id) {
                return itemsById.get(id);
            }

            const hotbarSlots = new Array(10).fill(null);
            const hotbarElements = [];
            let selectedHotbar = 0;

            function buildHotbar() {
                hotbar.innerHTML = '';
                hotbarSlots.forEach((_, index) => {
                    const slot = document.createElement('div');
                    slot.className = 'hotbarSlot';
                    slot.dataset.index = index;
                    slot.draggable = true;
                    slot.addEventListener('click', event => {
                        if (event.shiftKey && hotbarSlots[index]) {
                            setHotbarSlot(index, null);
                            return;
                        }
                        selectHotbarSlot(index);
                    });
                    slot.addEventListener('dragstart', event => {
                        if (!hotbarSlots[index]) {
                            event.preventDefault();
                            return;
                        }
                        event.dataTransfer.setData('text/plain', hotbarSlots[index]);
                        event.dataTransfer.setData('source-slot', String(index));
                    });
                    slot.addEventListener('dragover', event => {
                        event.preventDefault();
                        slot.classList.add('dropTarget');
                    });
                    slot.addEventListener('dragleave', () => slot.classList.remove('dropTarget'));
                    slot.addEventListener('drop', event => {
                        event.preventDefault();
                        slot.classList.remove('dropTarget');
                        const itemId = event.dataTransfer.getData('text/plain');
                        const fromSlot = event.dataTransfer.getData('source-slot');
                        if (fromSlot) {
                            const sourceIndex = Number(fromSlot);
                            hotbarSlots[sourceIndex] = hotbarSlots[index];
                        }
                        setHotbarSlot(index, itemId);
                    });
                    slot.addEventListener('mouseenter', () => {
                        const itemId = hotbarSlots[index];
                        if (!itemId) return;
                        const item = getItemDef(itemId);
                        if (item) {
                            setInventoryDetails(item);
                        }
                    });
                    slot.addEventListener('mouseleave', () => {
                        setInventoryDetails(null);
                    });
                    hotbar.appendChild(slot);
                    hotbarElements.push(slot);
                });
                updateHotbarDisplay();
                selectHotbarSlot(0);
            }

            function setHotbarSlot(index, itemId) {
                hotbarSlots[index] = itemId;
                updateHotbarDisplay();
            }

            function updateHotbarDisplay() {
                hotbarSlots.forEach((itemId, index) => {
                    const slot = hotbarElements[index];
                    slot.innerHTML = '';
                    if (itemId) {
                        const def = getItemDef(itemId);
                        const icon = document.createElement('div');
                        icon.className = 'icon';
                        icon.textContent = def.icon;
                        slot.appendChild(icon);
                    }
                    slot.classList.toggle('selected', index === selectedHotbar);
                });
            }

            function selectHotbarSlot(index) {
                selectedHotbar = index;
                updateHotbarDisplay();
            }

            function addToHotbar(itemId) {
                const emptyIndex = hotbarSlots.findIndex(slot => !slot);
                if (emptyIndex !== -1) {
                    setHotbarSlot(emptyIndex, itemId);
                }
            }

            function seedHotbarFromBlocks() {
                const blocks = itemsCatalog.filter(item => item.category === 'blocks');
                blocks.slice(0, hotbarSlots.length).forEach((item, index) => {
                    setHotbarSlot(index, item.id);
                });
            }

            function getCategoryForItem(item) {
                if (item.category && CATEGORY_ORDER.includes(item.category)) {
                    return item.category;
                }
                return DRAGGABLE_ITEMS.has(item.id) ? 'blocks' : 'parts';
            }

            function getCategoryColor(categoryId) {
                const match = INVENTORY_CATEGORIES.find(category => category.id === categoryId);
                return match ? match.color : '#777';
            }

            function sortItemsByName(items) {
                return items.slice().sort((a, b) => a.name.localeCompare(b.name));
            }

            function getFilteredItems() {
                const query = inventorySearchQuery.trim().toLowerCase();
                const searchFilter = item => {
                    if (!query) return true;
                    return item.name.toLowerCase().includes(query);
                };
                if (activeInventoryCategory === 'all') {
                    const ordered = [];
                    CATEGORY_ORDER.forEach(categoryId => {
                        const matching = itemsCatalog.filter(item => getCategoryForItem(item) === categoryId);
                        const filtered = sortItemsByName(matching.filter(searchFilter));
                        ordered.push(...filtered);
                    });
                    return ordered;
                }
                const categoryItems = itemsCatalog.filter(item => getCategoryForItem(item) === activeInventoryCategory);
                return sortItemsByName(categoryItems.filter(searchFilter));
            }

            function buildInventoryTabs() {
                if (!inventoryTabs) return;
                inventoryTabs.innerHTML = '';
                INVENTORY_CATEGORIES.forEach(category => {
                    const tab = document.createElement('button');
                    tab.type = 'button';
                    tab.className = 'inventoryTab';
                    tab.innerHTML = `<span class="tabLabel">${category.label}</span>`;
                    if (category.id === 'modParts') {
                        tab.classList.add('noDot');
                    }
                    tab.style.setProperty('--category-color', category.color);
                    tab.dataset.categoryId = category.id;
                    tab.addEventListener('click', () => {
                        setActiveInventoryCategory(category.id);
                    });
                    inventoryTabs.appendChild(tab);
                });
                updateInventoryTabs();
            }

            function updateInventoryTabs() {
                if (!inventoryTabs) return;
                inventoryTabs.querySelectorAll('.inventoryTab').forEach(tab => {
                    tab.classList.toggle('active', tab.dataset.categoryId === activeInventoryCategory);
                });
            }

            function setActiveInventoryCategory(categoryId) {
                activeInventoryCategory = categoryId;
                updateInventoryTabs();
                renderInventory();
            }

            function setInventorySearchQuery(value) {
                inventorySearchQuery = value || '';
                renderInventory();
            }

            function setInventoryDetails(item) {
                if (!inventoryDetails) return;
                if (!item) {
                    inventoryDetails.classList.add('empty');
                    inventoryDetails.style.setProperty('--detail-color', '#e08a2e');
                    if (inventoryDetailIcon) inventoryDetailIcon.textContent = '';
                    if (inventoryDetailName) inventoryDetailName.textContent = '';
                    if (inventoryDetailDesc) inventoryDetailDesc.textContent = '';
                    if (inventoryDetailStats) inventoryDetailStats.innerHTML = '';
                    return;
                }
                inventoryDetails.classList.remove('empty');
                inventoryDetails.style.setProperty('--detail-color', getCategoryColor(getCategoryForItem(item)));
                if (inventoryDetailIcon) inventoryDetailIcon.textContent = item.icon || '';
                if (inventoryDetailName) inventoryDetailName.textContent = item.name || '';
                if (inventoryDetailDesc) {
                    inventoryDetailDesc.textContent = item.description || '';
                }
                if (inventoryDetailStats) {
                    inventoryDetailStats.innerHTML = '';
                    (item.stats || []).forEach(stat => {
                        const row = document.createElement('div');
                        row.className = 'detailRow';
                        const label = document.createElement('span');
                        label.textContent = stat.label;
                        row.appendChild(label);
                        if (typeof stat.dots === 'number') {
                            const dots = document.createElement('span');
                            dots.className = 'detailDots';
                            for (let i = 0; i < 5; i++) {
                                const dot = document.createElement('span');
                                if (i < stat.dots) dot.classList.add('active');
                                dots.appendChild(dot);
                            }
                            row.appendChild(dots);
                        } else {
                            const value = document.createElement('span');
                            value.textContent = stat.value || '';
                            row.appendChild(value);
                        }
                        inventoryDetailStats.appendChild(row);
                    });
                }
            }

            function renderInventory() {
                setInventoryDetails(null);
                inventoryItems.innerHTML = '';
                const filteredItems = getFilteredItems();
                filteredItems.forEach(item => {
                    const categoryId = getCategoryForItem(item);
                    const card = document.createElement('div');
                    card.className = 'inventoryItem';
                    card.dataset.itemId = item.id;
                    card.style.setProperty('--category-color', getCategoryColor(categoryId));
                    if (categoryId === 'modParts') {
                        card.classList.add('noDot');
                    }
                    const isDraggable = DRAGGABLE_ITEMS.has(item.id);
                    card.draggable = isDraggable;
                    if (!isDraggable) {
                        card.classList.add('notDraggable');
                    }
                    card.innerHTML = `
                        <span class="icon">${item.icon}</span>
                        <span class="categoryDot"></span>
                    `;
                    card.addEventListener('mouseenter', () => setInventoryDetails(item));
                    card.addEventListener('mouseleave', () => setInventoryDetails(null));
                    if (isDraggable) {
                        card.addEventListener('dragstart', event => {
                            event.dataTransfer.setData('text/plain', item.id);
                        });
                    }
                    inventoryItems.appendChild(card);
                });
            }

            inventoryItems.addEventListener('click', event => {
                const card = event.target.closest('.inventoryItem');
                if (!card) return;
                if (event.shiftKey) {
                    addToHotbar(card.dataset.itemId);
                    updateHotbarDisplay();
                }
            });
            inventoryItems.addEventListener('dragover', event => {
                event.preventDefault();
            });
            inventoryItems.addEventListener('drop', event => {
                event.preventDefault();
                const fromSlot = event.dataTransfer.getData('source-slot');
                if (fromSlot) {
                    const sourceIndex = Number(fromSlot);
                    setHotbarSlot(sourceIndex, null);
                }
            });

            const controlsButtons = [];
            function buildControlsTable() {
                controlsList.innerHTML = '';
                actionDefinitions.forEach(action => {
                    const row = document.createElement('div');
                    row.className = 'controlRow';
                    const label = document.createElement('div');
                    label.className = 'controlLabel';
                    label.textContent = action.label;
                    row.appendChild(label);
                    [0, 1].forEach(slotIndex => {
                        const btn = document.createElement('button');
                        btn.type = 'button';
                        btn.className = 'keyButton';
                        btn.dataset.actionId = action.id;
                        btn.dataset.slotIndex = slotIndex;
                        updateKeyButton(btn, action.id, slotIndex);
                        btn.addEventListener('click', () => startListening(action.id, slotIndex, btn));
                        row.appendChild(btn);
                        controlsButtons.push(btn);
                    });
                    controlsList.appendChild(row);
                });
            }

            function isModifierCode(code) {
                return MODIFIER_KEYS.has(code);
            }

            function parseBinding(binding) {
                if (!binding) return [];
                if (Array.isArray(binding)) return binding.filter(Boolean);
                return String(binding).split('+').filter(Boolean);
            }

            function sortBindingCodes(codes) {
                const order = new Map(MODIFIER_ORDER.map((code, index) => [code, index]));
                return [...codes].sort((a, b) => {
                    const aMod = order.has(a);
                    const bMod = order.has(b);
                    if (aMod && bMod) return order.get(a) - order.get(b);
                    if (aMod) return -1;
                    if (bMod) return 1;
                    return a.localeCompare(b);
                });
            }

            function isValidBinding(codes) {
                if (!codes.length || codes.length > MAX_COMBO_KEYS) return false;
                const modifiers = codes.filter(isModifierCode);
                const nonModifiers = codes.filter(code => !isModifierCode(code));
                if (modifiers.length > 2 || nonModifiers.length > 1) return false;
                if (modifiers.length === 2 && nonModifiers.length === 0) return false;
                return true;
            }

            function normalizeBinding(codes) {
                const unique = Array.from(new Set(codes));
                if (!isValidBinding(unique)) return null;
                return sortBindingCodes(unique).join('+');
            }

            function codeToLabel(code) {
                if (!code) return 'Not Set';
                const map = {
                    Space: 'Space',
                    ShiftLeft: 'Shift',
                    ShiftRight: 'Shift',
                    ControlLeft: 'Ctrl',
                    ControlRight: 'Ctrl',
                    AltLeft: 'Alt',
                    AltRight: 'Alt',
                    MetaLeft: 'Meta',
                    MetaRight: 'Meta',
                    ArrowUp: 'Arrow Up',
                    ArrowDown: 'Arrow Down',
                    ArrowLeft: 'Arrow Left',
                    ArrowRight: 'Arrow Right',
                    Enter: 'Enter',
                    Tab: 'Tab',
                    Escape: 'Escape',
                    Mouse1: 'LMB',
                    Mouse2: 'RMB',
                    Mouse3: 'MB 3',
                    Mouse4: 'MB 4',
                    Mouse5: 'MB 5',
                    WheelUp: 'Scroll Up',
                    WheelDown: 'Scroll Down'
                };
                if (map[code]) return map[code];
                if (code.startsWith('Key')) return code.slice(3);
                if (code.startsWith('Digit')) return code.slice(5);
                return code;
            }

            function bindingToLabel(binding) {
                if (!binding) return 'Not Set';
                const codes = parseBinding(binding);
                if (!codes.length) return 'Not Set';
                return sortBindingCodes(codes).map(codeToLabel).join(' + ');
            }

            function updateKeyButton(button, actionId, slotIndex) {
                const bindings = keyBindings[actionId] || [];
                const binding = bindings[slotIndex] || null;
                button.textContent = bindingToLabel(binding);
                button.classList.toggle('muted', !binding);
            }

            function refreshAllKeyButtons() {
                document.querySelectorAll('.keyButton[data-action-id]').forEach(button => {
                    const actionId = button.dataset.actionId;
                    const slotIndex = Number(button.dataset.slotIndex);
                    if (!actionId || Number.isNaN(slotIndex)) return;
                    updateKeyButton(button, actionId, slotIndex);
                });
            }

            const optionsControlMap = new Map([
                ['Move Forward', 'moveForward'],
                ['Move Backward', 'moveBackward'],
                ['Move Left', 'moveLeft'],
                ['Move Right', 'moveRight'],
                ['Jump', 'jump'],
                ['Crouch', 'crouch'],
                ['Sprint', 'sprint'],
                ['Next Hotbar Item', 'hotbarNext'],
                ['Previous Hotbar Item', 'hotbarPrev'],
                ['Hotbar Item 1', 'hotbar0'],
                ['Hotbar Item 2', 'hotbar1'],
                ['Hotbar Item 3', 'hotbar2'],
                ['Hotbar Item 4', 'hotbar3'],
                ['Hotbar Item 5', 'hotbar4'],
                ['Hotbar Item 6', 'hotbar5'],
                ['Hotbar Item 7', 'hotbar6'],
                ['Hotbar Item 8', 'hotbar7'],
                ['Hotbar Item 9', 'hotbar8'],
                ['Hotbar Item 10', 'hotbar9'],
                ['Build / Primary', 'buildPrimary'],
                ['Remove / Secondary', 'removeSecondary'],
                ['Use', 'use'],
                ['Upgrade', 'upgrade'],
                ['Backpack', 'openInventory'],
                ['Logbook', 'logbook'],
                ['Next Rotation', 'cycleAxis'],
                ['Previous Rotation', 'cycleAxisReverse'],
                ['Lift Up', 'liftUp'],
                ['Lift Down', 'liftDown'],
                ['Force Build', 'forceBuild'],
                ['Reload', 'reload'],
                ['Zoom In', 'zoomIn'],
                ['Zoom Out', 'zoomOut'],
                ['Chat', 'chat'],
                ['Next Hotbar', 'creativeNextHotbar'],
                ['Previous Hotbar', 'creativePrevHotbar'],
                ['Select Hotbar 1', 'creativeHotbar1'],
                ['Select Hotbar 2', 'creativeHotbar2'],
                ['Select Hotbar 3', 'creativeHotbar3']
            ]);

            function initOptionsControlBindings() {
                const rows = document.querySelectorAll('.optionsPane[data-tab-panel="controls"] .controlRow');
                rows.forEach(row => {
                    const label = row.querySelector('.controlLabel');
                    if (!label) return;
                    const actionId = optionsControlMap.get(label.textContent.trim());
                    if (!actionId) return;
                    const buttons = Array.from(row.querySelectorAll('.keyButton'));
                    buttons.forEach((btn, index) => {
                        if (btn.dataset.bindInit === 'true') return;
                        btn.dataset.bindInit = 'true';
                        btn.dataset.actionId = actionId;
                        btn.dataset.slotIndex = index;
                        updateKeyButton(btn, actionId, index);
                        btn.addEventListener('click', () => startListening(actionId, index, btn));
                    });
                });
            }

            function updateDoubleTapButton() {
                if (!doubleTapModeBtn) return;
                const preset = doubleTapPresets[doubleTapPresetIndex];
                doubleTapModeBtn.textContent = `${preset.label} (${preset.min}-${preset.max}ms)`;
            }

            function setDoubleTapPreset(nextIndex) {
                doubleTapPresetIndex = (nextIndex + doubleTapPresets.length) % doubleTapPresets.length;
                const preset = doubleTapPresets[doubleTapPresetIndex];
                settings.doubleTapMin = preset.min;
                settings.doubleTapMax = preset.max;
                updateDoubleTapButton();
                resetJumpSequence();
            }

            let listening = null;
            function startListening(actionId, slotIndex, button) {
                if (listening && listening.button === button) return;
                stopListening();
                listening = {
                    actionId,
                    slotIndex,
                    button,
                    keys: new Set(),
                    lastCombo: []
                };
                button.classList.add('listening');
                button.textContent = 'Press keys...';
            }

            function updateListeningButton() {
                if (!listening) return;
                if (!listening.keys.size) {
                    listening.button.textContent = 'Press keys...';
                    return;
                }
                const codes = sortBindingCodes(Array.from(listening.keys));
                listening.button.textContent = codes.map(codeToLabel).join(' + ');
            }

            function stopListening() {
                if (!listening) return;
                listening.button.classList.remove('listening');
                updateKeyButton(listening.button, listening.actionId, listening.slotIndex);
                listening = null;
            }
            const pressedKeys = new Set();
            window.addEventListener('keydown', event => {
                const searchFocused = inventorySearchInput && document.activeElement === inventorySearchInput;
                if (searchFocused && event.code !== 'Tab') {
                    return;
                }
                if (chatOpen) {
                    if (event.code === 'Enter') {
                        event.preventDefault();
                        const value = chatInput ? chatInput.value.trim() : '';
                        if (value) {
                            addChatMessage(value);
                        }
                        closeChat();
                        return;
                    }
                    if (event.code === 'Tab' || event.code === 'Escape') {
                        event.preventDefault();
                        closeChat();
                        return;
                    }
                    return;
                }
                if (listening) {
                    event.preventDefault();
                    if (event.code === 'Tab') {
                        keyBindings[listening.actionId][listening.slotIndex] = null;
                        updateKeyButton(listening.button, listening.actionId, listening.slotIndex);
                        stopListening();
                        return;
                    }
                    if (event.repeat || listening.keys.has(event.code)) return;
                    if (listening.keys.size >= MAX_COMBO_KEYS) return;
                    listening.keys.add(event.code);
                    listening.lastCombo = Array.from(listening.keys);
                    updateListeningButton();
                    return;
                }
                const wasCycleAxis = isActionActive('cycleAxis');
                const wasCycleAxisReverse = isActionActive('cycleAxisReverse');
                const wasJump = isActionActive('jump');
                const wasPulse = isActionActive('pulse');
                const wasInventory = isActionActive('openInventory');
                const wasHotbar = new Array(10).fill(false);
                for (let i = 0; i < 10; i++) {
                    wasHotbar[i] = isActionActive(`hotbar${i}`);
                }
                pressedKeys.add(event.code);
                if (!wasCycleAxis && isActionActive('cycleAxis')) {
                    event.preventDefault();
                    cycleAxisMode(1);
                    return;
                }
                if (!wasCycleAxisReverse && isActionActive('cycleAxisReverse')) {
                    event.preventDefault();
                    cycleAxisMode(-1);
                    return;
                }
                if (!menuOpen && !inventoryOpen && !wasPulse && isActionActive('pulse')) {
                    event.preventDefault();
                    triggerPulseImpulse();
                    return;
                }
                if (!menuOpen && !inventoryOpen && !wasJump && isActionActive('jump')) {
                    jumpHoldActive = true;
                    jumpHoldTimer = 0;
                    handleJumpSignal('down', getActiveBinding('jump'));
                    triggerJumpImpulse();
                }
                if (!wasInventory && isActionActive('openInventory')) {
                    event.preventDefault();
                    toggleInventory();
                }
                if (!chatOpen && isActionActive('chat')) {
                    event.preventDefault();
                    openChat();
                    return;
                }
                for (let i = 0; i < 10; i++) {
                    if (!wasHotbar[i] && isActionActive(`hotbar${i}`)) {
                        event.preventDefault();
                        selectHotbarSlot(i);
                        break;
                    }
                }
                if (event.code === 'Tab') {
                    event.preventDefault();
                    if (inventoryOpen) {
                        tabClosingMenu = true;
                        toggleInventory(false);
                    } else if (menuOpen) {
                        tabClosingMenu = true;
                        if (activeMenuPage !== 'main') {
                            showMenuPage('main');
                        } else {
                            toggleMenu(false);
                        }
                    } else {
                        toggleMenu(true);
                    }
                    relockPointerIfPossible();
                    return;
                }
            });
            window.addEventListener('mousedown', event => {
                if (!listening) return;
                event.preventDefault();
                const mouseCodes = ['Mouse1', 'Mouse2', 'Mouse3', 'Mouse4', 'Mouse5'];
                const mouseCode = mouseCodes[event.button] || null;
                if (!mouseCode) return;
                const codes = Array.from(new Set([...listening.keys, mouseCode]));
                const normalized = normalizeBinding(codes);
                if (normalized) {
                    keyBindings[listening.actionId][listening.slotIndex] = normalized;
                }
                updateKeyButton(listening.button, listening.actionId, listening.slotIndex);
                stopListening();
            });

            window.addEventListener('keyup', event => {
                const searchFocused = inventorySearchInput && document.activeElement === inventorySearchInput;
                if (searchFocused) {
                    return;
                }
                if (listening) {
                    event.preventDefault();
                    if (listening.keys.has(event.code)) {
                        listening.keys.delete(event.code);
                    }
                    if (!listening.keys.size) {
                        const normalized = normalizeBinding(listening.lastCombo);
                        if (normalized) {
                            keyBindings[listening.actionId][listening.slotIndex] = normalized;
                        }
                        updateKeyButton(listening.button, listening.actionId, listening.slotIndex);
                        stopListening();
                    } else {
                        updateListeningButton();
                    }
                    return;
                }
                const wasJumpActive = isActionActive('jump');
                const wasJumpBinding = wasJumpActive ? getActiveBinding('jump') : null;
                pressedKeys.delete(event.code);
                if (!menuOpen && !inventoryOpen && wasJumpActive && !isActionActive('jump')) {
                    jumpHoldActive = false;
                    handleJumpSignal('up', wasJumpBinding);
                }
            });

            window.addEventListener('blur', () => {
                pressedKeys.clear();
                jumpHoldActive = false;
                resetJumpSequence();
                resetDragState(false);
                cancelPlacementHold();
                cancelBreakHold();
                resetPointerState();
            });

            function isBindingActiveCodes(codes) {
                return codes.every(code => pressedKeys.has(code));
            }

            function getActiveBinding(actionId) {
                const bindings = keyBindings[actionId] || [];
                for (const binding of bindings) {
                    const codes = parseBinding(binding);
                    if (!isValidBinding(codes)) continue;
                    if (isBindingActiveCodes(codes)) {
                        return normalizeBinding(codes);
                    }
                }
                return null;
            }

            function isActionActive(actionId) {
                return Boolean(getActiveBinding(actionId));
            }

            function selectHotbarByAction(actionId) {
                if (!actionId.startsWith('hotbar')) return;
                const index = Number(actionId.replace('hotbar', ''));
                if (!Number.isNaN(index) && index >= 0 && index < hotbarSlots.length) {
                    selectHotbarSlot(index);
                }
            }

            let menuOpen = false;
            let inventoryOpen = false;
            let activeMenuPage = 'main';
            let tabClosingMenu = false;
            let isFlying = false;
            let chatOpen = false;
            const CROUCH_FACTOR = 0.5;
            let crouchState = false;
            const MAX_INTERACT_DISTANCE = 16;
            const REPLACEABLE_BLOCKS = new Set(['flower']);
            const GROUND_FRICTION = 6;
            const AIR_FRICTION = 4;
            const JumpStages = {
                WAITING_DOWN1: 0,
                WAITING_UP1: 1,
                WAITING_DOWN2: 2
            };
            let jumpSequenceStage = JumpStages.WAITING_DOWN1;
            let jumpSequenceBinding = null;
            let lastJumpSignalTime = 0;

            function relockPointerIfPossible() {
                if (!menuOpen && !inventoryOpen && !chatOpen) {
                    tabClosingMenu = false;
                    canvas.requestPointerLock();
                }
            }

            function openChat() {
                if (menuOpen || inventoryOpen) return;
                chatOpen = true;
                if (chatPanel) {
                    chatPanel.classList.add('active');
                }
                exitPointerLock();
                if (chatInput) {
                    chatInput.value = '';
                    chatInput.focus();
                }
                refreshCrosshairVisibility();
            }

            function closeChat() {
                chatOpen = false;
                if (chatPanel) {
                    chatPanel.classList.remove('active');
                }
                if (chatInput) {
                    chatInput.blur();
                }
                relockPointerIfPossible();
                refreshCrosshairVisibility();
            }

            function addChatMessage(text) {
                if (!chatMessages) return;
                const msg = document.createElement('div');
                msg.className = 'chatMessage';
                msg.textContent = text;
                chatMessages.appendChild(msg);
                while (chatMessages.children.length > 6) {
                    chatMessages.removeChild(chatMessages.firstChild);
                }
            }

            function showMenuPage(pageId) {
                activeMenuPage = pageId;
                document.querySelectorAll('.menuPage').forEach(page => {
                    page.classList.toggle('active', page.dataset.page === pageId);
                });
                if (pageId === 'options') {
                    syncOptionsTab();
                }
            }

            function setOptionsTab(tabId) {
                optionsTabButtons.forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.tab === tabId);
                });
                optionsTabPanels.forEach(panel => {
                    panel.classList.toggle('active', panel.dataset.tabPanel === tabId);
                });
                const scrollArea = document.querySelector('.optionsScroll');
                if (scrollArea) {
                    scrollArea.scrollTop = 0;
                }
            }

            function syncOptionsTab() {
                if (!optionsTabButtons.length) return;
                const activeButton = optionsTabButtons.find(btn => btn.classList.contains('active')) || optionsTabButtons[0];
                if (activeButton) {
                    setOptionsTab(activeButton.dataset.tab);
                }
            }

            function toggleMenu(forceState) {
                const next = typeof forceState === 'boolean' ? forceState : !menuOpen;
                if (next === menuOpen) {
                    return;
                }
                menuOpen = next;
                menuOverlay.classList.toggle('visible', menuOpen);
                if (menuOpen) {
                    resetDragState(false);
                    cancelPlacementHold();
                    cancelBreakHold();
                    resetPointerState();
                    exitPointerLock();
                    showMenuPage(activeMenuPage);
                }
                refreshCrosshairVisibility();
            }

            function toggleInventory(forceState) {
                const next = typeof forceState === 'boolean' ? forceState : !inventoryOpen;
                if (next === inventoryOpen) {
                    return;
                }
                inventoryOpen = next;
                inventoryOverlay.classList.toggle('visible', inventoryOpen);
                if (inventoryOpen) {
                    resetDragState(false);
                    cancelPlacementHold();
                    cancelBreakHold();
                    resetPointerState();
                    exitPointerLock();
                } else {
                    relockPointerIfPossible();
                }
                refreshCrosshairVisibility();
            }

            resumeBtn.addEventListener('click', () => {
                toggleMenu(false);
                relockPointerIfPossible();
            });
            videoBtn.addEventListener('click', () => {});
            accessibilityBtn.addEventListener('click', () => {
                showMenuPage('options');
            });
            controlsBtn.addEventListener('click', () => {
                window.location.reload();
            });
            if (optionsVideoBtn) {
                optionsVideoBtn.addEventListener('click', () => {
                    showMenuPage('video');
                });
            }
            if (optionsAccessibilityBtn) {
                optionsAccessibilityBtn.addEventListener('click', () => {
                    showMenuPage('accessibility');
                });
            }
            if (optionsControlsBtn) {
                optionsControlsBtn.addEventListener('click', () => {
                    showMenuPage('controls');
                });
            }
            if (optionsTabButtons.length) {
                optionsTabButtons.forEach(btn => {
                    btn.addEventListener('click', () => {
                        setOptionsTab(btn.dataset.tab);
                    });
                });
            }
            document.querySelectorAll('.backBtn[data-target="main"]').forEach(btn => {
                btn.addEventListener('click', () => {
                    showMenuPage('main');
                });
            });
            if (closeInventoryBtn) {
                closeInventoryBtn.addEventListener('click', () => {
                    toggleInventory(false);
                    relockPointerIfPossible();
                });
            }
            if (doubleTapModeBtn) {
                doubleTapModeBtn.addEventListener('click', () => {
                    setDoubleTapPreset(doubleTapPresetIndex + 1);
                });
                updateDoubleTapButton();
            }

            function exitPointerLock() {
                if (document.pointerLockElement === canvas) {
                    document.exitPointerLock();
                }
            }

            function refreshCrosshairVisibility() {
                const locked = document.pointerLockElement === canvas;
                const shouldShowCrosshair = locked && !menuOpen && !inventoryOpen;
                crosshair.style.display = shouldShowCrosshair ? 'block' : 'none';
                if (!shouldShowCrosshair) {
                    setBreakProgressVisible(false);
                } else if (breakHoldState) {
                    setBreakProgressVisible(true);
                }
            }

            canvas.addEventListener('click', () => {
                if (menuOpen || inventoryOpen) return;
                if (document.pointerLockElement !== canvas) {
                    canvas.requestPointerLock();
                }
            });

            document.addEventListener('pointerlockchange', () => {
                refreshCrosshairVisibility();
                if (document.pointerLockElement !== canvas) {
                    resetDragState(false);
                    cancelPlacementHold();
                    cancelBreakHold();
                    resetPointerState();
                }
            });

            document.addEventListener('mousemove', event => {
                if (document.pointerLockElement !== canvas) return;
                const sensitivity = settings.aimSensitivity;
                camera.yaw -= event.movementX * sensitivity;
                camera.pitch -= event.movementY * sensitivity;
                const limit = Math.PI / 2 - 0.05;
                camera.pitch = Math.max(-limit, Math.min(limit, camera.pitch));
            });

            canvas.addEventListener('mousedown', event => {
                if (menuOpen || inventoryOpen) return;
                if (event.button === 0) {
                    handleLeftDown();
                } else if (event.button === 2) {
                    handleRightDown();
                }
            });
            canvas.addEventListener('contextmenu', event => event.preventDefault());
            document.addEventListener('mouseup', event => {
                if (event.button === 0) {
                    handleLeftUp();
                } else if (event.button === 2) {
                    handleRightUp();
                }
            });

            document.addEventListener('wheel', event => {
                if (menuOpen || inventoryOpen) return;
                const dir = Math.sign(event.deltaY);
                if (dir > 0) {
                    selectHotbarSlot((selectedHotbar + 1) % hotbarSlots.length);
                } else if (dir < 0) {
                    selectHotbarSlot((selectedHotbar - 1 + hotbarSlots.length) % hotbarSlots.length);
                }
            });

            fovSlider.addEventListener('input', () => {
                settings.fov = Number(fovSlider.value);
                fovValue.textContent = settings.fov + '\u00B0';
            });
            const SETTINGS_STORAGE_KEY = 'gameSettings';

            function aimSensitivityFromSlider(value) {
                const numericValue = Number(value);
                if (Number.isNaN(numericValue)) return settings.aimSensitivity;
                const clamped = Math.max(10, Math.min(200, numericValue));
                return AIM_SENS_MIN + ((clamped - 10) / 190) * (AIM_SENS_MAX - AIM_SENS_MIN);
            }

            function aimSensitivityToSliderValue(sensitivity) {
                const clamped = Math.max(AIM_SENS_MIN, Math.min(AIM_SENS_MAX, sensitivity));
                return Math.round(10 + ((clamped - AIM_SENS_MIN) / (AIM_SENS_MAX - AIM_SENS_MIN)) * 190);
            }

            function updateAimSensitivity(value) {
                const numericValue = Number(value);
                if (Number.isNaN(numericValue)) return;
                settings.aimSensitivity = aimSensitivityFromSlider(numericValue);
                if (aimSensitivityValue) {
                    aimSensitivityValue.textContent = Math.max(10, Math.min(200, numericValue));
                }
            }

            function updateDisplayFov(value) {
                const numericValue = Number(value);
                if (Number.isNaN(numericValue)) return;
                settings.fov = numericValue;
                if (displayFovValue) {
                    displayFovValue.textContent = numericValue;
                }
                if (fovSlider) {
                    fovSlider.value = numericValue;
                }
                if (fovValue) {
                    fovValue.textContent = numericValue + '\u00B0';
                }
            }

            function applySettingsToUi() {
                if (aimSensitivitySlider) {
                    const sliderValue = aimSensitivityToSliderValue(settings.aimSensitivity);
                    aimSensitivitySlider.value = sliderValue;
                    if (aimSensitivityValue) {
                        aimSensitivityValue.textContent = sliderValue;
                    }
                }
                if (displayFovSlider) {
                    displayFovSlider.value = settings.fov;
                    if (displayFovValue) {
                        displayFovValue.textContent = settings.fov;
                    }
                }
                if (fovSlider) {
                    fovSlider.value = settings.fov;
                }
                if (fovValue) {
                    fovValue.textContent = settings.fov + '\u00B0';
                }
                updateFlightSpeedButton();
            }

            function serializeSettings() {
                return JSON.stringify({
                    aimSensitivity: settings.aimSensitivity,
                    fov: settings.fov,
                    flightSpeed: settings.flightSpeed,
                    bindings: keyBindings
                });
            }

            async function saveSettingsToFile() {
                const data = serializeSettings();
                localStorage.setItem(SETTINGS_STORAGE_KEY, data);
            }

            async function loadSettings() {
                const cached = localStorage.getItem(SETTINGS_STORAGE_KEY);
                if (cached) {
                    try {
                        const parsed = JSON.parse(cached);
                        if (parsed && typeof parsed === 'object') {
                            if (typeof parsed.aimSensitivity === 'number') {
                                settings.aimSensitivity = parsed.aimSensitivity;
                            }
                            if (typeof parsed.fov === 'number') {
                                settings.fov = parsed.fov;
                            }
                            if (typeof parsed.flightSpeed === 'string') {
                                settings.flightSpeed = parsed.flightSpeed;
                            }
                            if (parsed.bindings && typeof parsed.bindings === 'object') {
                                actionDefinitions.forEach(def => {
                                    const stored = parsed.bindings[def.id];
                                    if (!Array.isArray(stored)) return;
                                    const normalized = [stored[0] || null, stored[1] || null];
                                    keyBindings[def.id] = normalized;
                                });
                            }
                        }
                    } catch (error) {
                        // Ignore invalid storage.
                    }
                }
                applySettingsToUi();
                refreshAllKeyButtons();
            }

            if (aimSensitivitySlider) {
                updateAimSensitivity(aimSensitivitySlider.value);
                aimSensitivitySlider.addEventListener('input', () => {
                    updateAimSensitivity(aimSensitivitySlider.value);
                });
            }
            if (displayFovSlider) {
                updateDisplayFov(displayFovSlider.value);
                displayFovSlider.addEventListener('input', () => {
                    updateDisplayFov(displayFovSlider.value);
                });
            }
            const flightSpeedPresets = [
                { id: 'slow', label: 'Slow', baseSpeed: 6 },
                { id: 'normal', label: 'Normal', baseSpeed: 10 },
                { id: 'fast', label: 'Fast', baseSpeed: 14 }
            ];

            function getFlightSpeedPreset() {
                return flightSpeedPresets.find(preset => preset.id === settings.flightSpeed) || flightSpeedPresets[1];
            }

            function updateFlightSpeedButton() {
                if (!flightSpeedBtn) return;
                flightSpeedBtn.textContent = getFlightSpeedPreset().label;
            }

            if (flightSpeedBtn) {
                updateFlightSpeedButton();
                flightSpeedBtn.addEventListener('click', () => {
                    const currentIndex = flightSpeedPresets.findIndex(preset => preset.id === settings.flightSpeed);
                    const nextIndex = (currentIndex + 1) % flightSpeedPresets.length;
                    settings.flightSpeed = flightSpeedPresets[nextIndex].id;
                    updateFlightSpeedButton();
                });
            }
            if (optionsApplyBtn) {
                optionsApplyBtn.addEventListener('click', () => {
                    saveSettingsToFile();
                    refreshAllKeyButtons();
                });
            }
            if (optionsDefaultBtn) {
                optionsDefaultBtn.addEventListener('click', () => {
                    settings.aimSensitivity = aimSensitivityFromSlider(DEFAULT_AIM_SLIDER);
                    settings.fov = DEFAULT_FOV;
                    settings.flightSpeed = DEFAULT_FLIGHT_SPEED;
                    localStorage.removeItem(SETTINGS_STORAGE_KEY);
                    applySettingsToUi();
                    if (aimSensitivitySlider) {
                        updateAimSensitivity(aimSensitivitySlider.value);
                    }
                    if (displayFovSlider) {
                        updateDisplayFov(displayFovSlider.value);
                    }
                    updateFlightSpeedButton();
                });
            }
            loadSettings();
            async function initGameData() {
                await loadBlocksCatalog();
                const canisters = await loadInteractiveCanisters();
                itemsCatalog = itemsCatalog.concat(canisters);
                rebuildItemIndex();
                canisters.forEach(item => {
                    inventoryState[item.id] = 6;
                    ensureCanisterMesh(item.id);
                });
                buildInventoryTabs();
                renderInventory();
                buildHotbar();
                loadBlockTextures();
                loadObjectTextures();
            }
            initGameData();

            if (inventorySearchInput) {
                inventorySearchInput.addEventListener('input', () => {
                    setInventorySearchQuery(inventorySearchInput.value);
                });
            }
            buildControlsTable();
            initOptionsControlBindings();
            refreshCrosshairVisibility();

            const vertexSource = `
                attribute vec3 position;
                attribute vec2 uv;
                attribute vec3 normal;
                uniform mat4 uProjection;
                uniform mat4 uView;
                uniform mat4 uModel;
                varying vec2 vUv;
                varying vec3 vNormal;
                varying vec3 vWorldPos;
                void main() {
                    vUv = uv;
                    vec4 worldPos = uModel * vec4(position, 1.0);
                    vWorldPos = worldPos.xyz;
                    vNormal = mat3(uModel) * normal;
                    gl_Position = uProjection * uView * worldPos;
                }
            `;

            const fragmentSource = `
                ${supportsDerivatives ? '#extension GL_OES_standard_derivatives : enable' : ''}
                precision mediump float;
                #define HAS_DERIVATIVES ${supportsDerivatives ? 1 : 0}
                varying vec2 vUv;
                varying vec3 vNormal;
                varying vec3 vWorldPos;
                uniform vec3 uColor;
                uniform int uUseChecker;
                uniform int uUseTexture;
                uniform int uUseNormal;
                uniform int uUseAsg;
                uniform int uUseLighting;
                uniform int uUseMeshUv;
                uniform float uTile;
                uniform vec3 uTextureAnchor;
                uniform vec3 uObjectOrigin;
                uniform mat3 uTextureRotInv;
                uniform sampler2D uTexture;
                uniform sampler2D uNormalMap;
                uniform sampler2D uAsgMap;
                uniform vec3 uCameraPos;
                uniform float uAlpha;
                void main() {
                    vec3 baseNormal = normalize(vNormal);
                    vec2 uvCoord = vUv;
                    if (uUseTexture == 1 || uUseNormal == 1 || uUseAsg == 1) {
                        if (uUseMeshUv == 0) {
                            vec3 texPos = uTextureRotInv * (vWorldPos - uObjectOrigin) + uTextureAnchor;
                            vec3 absNormal = abs(baseNormal);
                            if (absNormal.y >= absNormal.x && absNormal.y >= absNormal.z) {
                                uvCoord = texPos.xz;
                            } else if (absNormal.x >= absNormal.z) {
                                uvCoord = texPos.zy;
                            } else {
                                uvCoord = texPos.xy;
                            }
                            uvCoord /= max(uTile, 0.0001);
                        }
                    }
                    vec3 baseColor = uColor;
                    if (uUseTexture == 1) {
                        vec3 texel = texture2D(uTexture, uvCoord).rgb;
                        if (uUseMeshUv == 1) {
                            float maxc = max(texel.r, max(texel.g, texel.b));
                            float minc = min(texel.r, min(texel.g, texel.b));
                            float sat = maxc > 0.0001 ? (maxc - minc) / maxc : 0.0;
                            float keepOriginal = smoothstep(0.12, 0.28, sat);
                            baseColor = mix(uColor, texel, keepOriginal);
                        } else {
                            float detail = dot(texel, vec3(0.2126, 0.7152, 0.0722));
                            detail = mix(0.8, 1.2, detail);
                            baseColor = uColor * detail;
                        }
                    }
                    if (uUseChecker == 1) {
                        vec2 tile = floor(abs(vUv * 3.0));
                        float checker = mod(tile.x + tile.y, 2.0);
                        float shade = mix(0.16, 0.22, checker);
                        vec3 base = vec3(0.13, 0.4, 0.13);
                        gl_FragColor = vec4(base * shade * 4.0, uAlpha);
                    } else {
                        vec3 color = baseColor;
                        if (uUseLighting == 1) {
                            vec3 normal = baseNormal;
                            if (uUseNormal == 1) {
                                #if HAS_DERIVATIVES
                                vec3 dp1 = dFdx(vWorldPos);
                                vec3 dp2 = dFdy(vWorldPos);
                                vec2 duv1 = dFdx(uvCoord);
                                vec2 duv2 = dFdy(uvCoord);
                                vec3 tangent = normalize(dp1 * duv2.y - dp2 * duv1.y);
                                vec3 bitangent = normalize(-dp1 * duv2.x + dp2 * duv1.x);
                                mat3 tbn = mat3(tangent, bitangent, normal);
                                vec3 mapNormal = texture2D(uNormalMap, uvCoord).xyz * 2.0 - 1.0;
                                normal = normalize(tbn * mapNormal);
                                #endif
                            }
                            float ao = 1.0;
                            float roughness = 0.6;
                            float specular = 0.2;
                            if (uUseAsg == 1) {
                                vec4 asg = texture2D(uAsgMap, uvCoord);
                                ao = (asg.r > 0.003) ? asg.r : asg.a;
                                roughness = asg.g;
                                specular = (asg.b > 0.003) ? asg.b : specular;
                            }
                            vec3 lightDir = normalize(vec3(0.35, 0.8, 0.45));
                            vec3 viewDir = normalize(uCameraPos - vWorldPos);
                            float ndl = max(dot(normal, lightDir), 0.0);
                            vec3 diffuse = baseColor * ndl;
                            vec3 ambient = baseColor * 0.22;
                            vec3 halfDir = normalize(lightDir + viewDir);
                            float shininess = mix(8.0, 96.0, 1.0 - roughness);
                            float specAmount = pow(max(dot(normal, halfDir), 0.0), shininess) * specular;
                            vec3 spec = vec3(specAmount);
                            color = (ambient + diffuse) * ao + spec;
                            color = pow(color, vec3(1.0 / 2.2));
                        } else if (uUseTexture == 1) {
                            color = pow(baseColor, vec3(1.0 / 2.2));
                        }
                        gl_FragColor = vec4(color, uAlpha);
                    }
                }
            `;
            function createShader(type, source) {
                const shader = gl.createShader(type);
                gl.shaderSource(shader, source);
                gl.compileShader(shader);
                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                    console.error(gl.getShaderInfoLog(shader));
                    gl.deleteShader(shader);
                    return null;
                }
                return shader;
            }

            function createProgram(vertexSrc, fragmentSrc) {
                const vertexShader = createShader(gl.VERTEX_SHADER, vertexSrc);
                const fragmentShader = createShader(gl.FRAGMENT_SHADER, fragmentSrc);
                const program = gl.createProgram();
                gl.attachShader(program, vertexShader);
                gl.attachShader(program, fragmentShader);
                gl.linkProgram(program);
                if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                    console.error(gl.getProgramInfoLog(program));
                    return null;
                }
                return program;
            }

            function buildLineBuffer(pairs) {
                const data = [];
                pairs.forEach(pair => {
                    pair.forEach(point => {
                        data.push(point[0], point[1], point[2], 0, 0);
                    });
                });
                return new Float32Array(data);
            }

            const program = createProgram(vertexSource, fragmentSource);
            gl.useProgram(program);
            gl.enable(gl.BLEND);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

            const planeBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, planeBuffer);
            const size = 400.0;
            const planeVertices = new Float32Array([
                -size, 0.0, -size, -size / 8, -size / 8, 0, 1, 0,
                 size, 0.0, -size,  size / 8, -size / 8, 0, 1, 0,
                 size, 0.0,  size,  size / 8,  size / 8, 0, 1, 0,
                -size, 0.0, -size, -size / 8, -size / 8, 0, 1, 0,
                 size, 0.0,  size,  size / 8,  size / 8, 0, 1, 0,
                -size, 0.0,  size, -size / 8,  size / 8, 0, 1, 0
            ]);
            gl.bufferData(gl.ARRAY_BUFFER, planeVertices, gl.STATIC_DRAW);

            const cubeBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, cubeBuffer);
            const cubeVertices = new Float32Array([
                -0.5, -0.5,  0.5, 0, 0, 0, 0, 1,
                 0.5, -0.5,  0.5, 1, 0, 0, 0, 1,
                 0.5,  0.5,  0.5, 1, 1, 0, 0, 1,
                -0.5, -0.5,  0.5, 0, 0, 0, 0, 1,
                 0.5,  0.5,  0.5, 1, 1, 0, 0, 1,
                -0.5,  0.5,  0.5, 0, 1, 0, 0, 1,
                -0.5, -0.5, -0.5, 1, 0, 0, 0, -1,
                -0.5,  0.5, -0.5, 1, 1, 0, 0, -1,
                 0.5,  0.5, -0.5, 0, 1, 0, 0, -1,
                -0.5, -0.5, -0.5, 1, 0, 0, 0, -1,
                 0.5,  0.5, -0.5, 0, 1, 0, 0, -1,
                 0.5, -0.5, -0.5, 0, 0, 0, 0, -1,
                -0.5, -0.5, -0.5, 0, 0, -1, 0, 0,
                -0.5, -0.5,  0.5, 1, 0, -1, 0, 0,
                -0.5,  0.5,  0.5, 1, 1, -1, 0, 0,
                -0.5, -0.5, -0.5, 0, 0, -1, 0, 0,
                -0.5,  0.5,  0.5, 1, 1, -1, 0, 0,
                -0.5,  0.5, -0.5, 0, 1, -1, 0, 0,
                 0.5, -0.5, -0.5, 1, 0, 1, 0, 0,
                 0.5,  0.5, -0.5, 1, 1, 1, 0, 0,
                 0.5,  0.5,  0.5, 0, 1, 1, 0, 0,
                 0.5, -0.5, -0.5, 1, 0, 1, 0, 0,
                 0.5,  0.5,  0.5, 0, 1, 1, 0, 0,
                 0.5, -0.5,  0.5, 0, 0, 1, 0, 0,
                -0.5,  0.5, -0.5, 0, 0, 0, 1, 0,
                -0.5,  0.5,  0.5, 0, 1, 0, 1, 0,
                 0.5,  0.5,  0.5, 1, 1, 0, 1, 0,
                -0.5,  0.5, -0.5, 0, 0, 0, 1, 0,
                 0.5,  0.5,  0.5, 1, 1, 0, 1, 0,
                 0.5,  0.5, -0.5, 1, 0, 0, 1, 0,
                -0.5, -0.5, -0.5, 1, 1, 0, -1, 0,
                 0.5, -0.5, -0.5, 0, 1, 0, -1, 0,
                 0.5, -0.5,  0.5, 0, 0, 0, -1, 0,
                -0.5, -0.5, -0.5, 1, 1, 0, -1, 0,
                 0.5, -0.5,  0.5, 0, 0, 0, -1, 0,
                -0.5, -0.5,  0.5, 1, 0, 0, -1, 0
            ]);
            gl.bufferData(gl.ARRAY_BUFFER, cubeVertices, gl.STATIC_DRAW);
            const cubeFaceOffsets = [0, 6, 12, 18, 24, 30];
            const cubeFaceDirections = [
                [0, 0, 1],
                [0, 0, -1],
                [-1, 0, 0],
                [1, 0, 0],
                [0, 1, 0],
                [0, -1, 0]
            ];
            const cubeEdgePairs = [
                [[-0.5, -0.5, -0.5], [0.5, -0.5, -0.5]],
                [[0.5, -0.5, -0.5], [0.5, -0.5, 0.5]],
                [[0.5, -0.5, 0.5], [-0.5, -0.5, 0.5]],
                [[-0.5, -0.5, 0.5], [-0.5, -0.5, -0.5]],
                [[-0.5, 0.5, -0.5], [0.5, 0.5, -0.5]],
                [[0.5, 0.5, -0.5], [0.5, 0.5, 0.5]],
                [[0.5, 0.5, 0.5], [-0.5, 0.5, 0.5]],
                [[-0.5, 0.5, 0.5], [-0.5, 0.5, -0.5]],
                [[-0.5, -0.5, -0.5], [-0.5, 0.5, -0.5]],
                [[0.5, -0.5, -0.5], [0.5, 0.5, -0.5]],
                [[0.5, -0.5, 0.5], [0.5, 0.5, 0.5]],
                [[-0.5, -0.5, 0.5], [-0.5, 0.5, 0.5]]
            ];
            const cubeEdgeBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, cubeEdgeBuffer);
            const cubeEdgeVertices = buildLineBuffer(cubeEdgePairs);
            gl.bufferData(gl.ARRAY_BUFFER, cubeEdgeVertices, gl.STATIC_DRAW);
            const cubeEdgeVertexCount = cubeEdgeVertices.length / 5;
            const cubeFaceEdgeBuffers = [];
            const cubeFaceEdgeVertexCounts = [];
            const faceEdges = [
                [
                    [[-0.5, -0.5, 0.5], [0.5, -0.5, 0.5]],
                    [[0.5, -0.5, 0.5], [0.5, 0.5, 0.5]],
                    [[0.5, 0.5, 0.5], [-0.5, 0.5, 0.5]],
                    [[-0.5, 0.5, 0.5], [-0.5, -0.5, 0.5]]
                ],
                [
                    [[-0.5, -0.5, -0.5], [0.5, -0.5, -0.5]],
                    [[0.5, -0.5, -0.5], [0.5, 0.5, -0.5]],
                    [[0.5, 0.5, -0.5], [-0.5, 0.5, -0.5]],
                    [[-0.5, 0.5, -0.5], [-0.5, -0.5, -0.5]]
                ],
                [
                    [[-0.5, -0.5, -0.5], [-0.5, -0.5, 0.5]],
                    [[-0.5, -0.5, 0.5], [-0.5, 0.5, 0.5]],
                    [[-0.5, 0.5, 0.5], [-0.5, 0.5, -0.5]],
                    [[-0.5, 0.5, -0.5], [-0.5, -0.5, -0.5]]
                ],
                [
                    [[0.5, -0.5, -0.5], [0.5, -0.5, 0.5]],
                    [[0.5, -0.5, 0.5], [0.5, 0.5, 0.5]],
                    [[0.5, 0.5, 0.5], [0.5, 0.5, -0.5]],
                    [[0.5, 0.5, -0.5], [0.5, -0.5, -0.5]]
                ],
                [
                    [[-0.5, 0.5, -0.5], [0.5, 0.5, -0.5]],
                    [[0.5, 0.5, -0.5], [0.5, 0.5, 0.5]],
                    [[0.5, 0.5, 0.5], [-0.5, 0.5, 0.5]],
                    [[-0.5, 0.5, 0.5], [-0.5, 0.5, -0.5]]
                ],
                [
                    [[-0.5, -0.5, -0.5], [0.5, -0.5, -0.5]],
                    [[0.5, -0.5, -0.5], [0.5, -0.5, 0.5]],
                    [[0.5, -0.5, 0.5], [-0.5, -0.5, 0.5]],
                    [[-0.5, -0.5, 0.5], [-0.5, -0.5, -0.5]]
                ]
            ];
            faceEdges.forEach(edges => {
                const buffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
                const verts = buildLineBuffer(edges);
                gl.bufferData(gl.ARRAY_BUFFER, verts, gl.STATIC_DRAW);
                cubeFaceEdgeBuffers.push(buffer);
                cubeFaceEdgeVertexCounts.push(verts.length / 5);
            });
            const squareEdgePairs = [
                [[-0.5, 0, -0.5], [0.5, 0, -0.5]],
                [[0.5, 0, -0.5], [0.5, 0, 0.5]],
                [[0.5, 0, 0.5], [-0.5, 0, 0.5]],
                [[-0.5, 0, 0.5], [-0.5, 0, -0.5]]
            ];
            const squareEdgeBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, squareEdgeBuffer);
            const squareEdgeVertices = buildLineBuffer(squareEdgePairs);
            gl.bufferData(gl.ARRAY_BUFFER, squareEdgeVertices, gl.STATIC_DRAW);
            const squareEdgeVertexCount = squareEdgeVertices.length / 5;
            const arrowBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, arrowBuffer);
            const arrowVertices = new Float32Array([
                -0.3, -0.04, 0, 0, 0,
                 0.3, -0.04, 0, 0, 0,
                 0.3,  0.04, 0, 0, 0,
                -0.3, -0.04, 0, 0, 0,
                 0.3,  0.04, 0, 0, 0,
                -0.3,  0.04, 0, 0, 0,
                -0.04, -0.3, 0, 0, 0,
                 0.04, -0.3, 0, 0, 0,
                 0.04,  0.3, 0, 0, 0,
                -0.04, -0.3, 0, 0, 0,
                 0.04,  0.3, 0, 0, 0,
                -0.04,  0.3, 0, 0, 0,
                 0.3,  0.1, 0, 0, 0,
                 0.3, -0.1, 0, 0, 0,
                 0.44,  0.0,  0, 0, 0,
                -0.3,  0.1, 0, 0, 0,
                -0.44,  0.0,  0, 0, 0,
                -0.3, -0.1, 0, 0, 0,
                 0.1,  0.3, 0, 0, 0,
                -0.1,  0.3, 0, 0, 0,
                 0.0,   0.44, 0, 0, 0,
                 0.1, -0.3, 0, 0, 0,
                 0.0,  -0.44, 0, 0, 0,
                -0.1, -0.3, 0, 0, 0
            ]);
            gl.bufferData(gl.ARRAY_BUFFER, arrowVertices, gl.STATIC_DRAW);
            const arrowVertexCount = arrowVertices.length / 5;
            const arrowOutlinePairs = [
                [[-0.3, -0.04, 0], [0.3, -0.04, 0]],
                [[0.3, -0.04, 0], [0.3, 0.04, 0]],
                [[0.3, 0.04, 0], [-0.3, 0.04, 0]],
                [[-0.3, 0.04, 0], [-0.3, -0.04, 0]],
                [[-0.04, -0.3, 0], [0.04, -0.3, 0]],
                [[0.04, -0.3, 0], [0.04, 0.3, 0]],
                [[0.04, 0.3, 0], [-0.04, 0.3, 0]],
                [[-0.04, 0.3, 0], [-0.04, -0.3, 0]],
                [[0.3, 0.1, 0], [0.44, 0, 0]],
                [[0.44, 0, 0], [0.3, -0.1, 0]],
                [[-0.3, 0.1, 0], [-0.44, 0, 0]],
                [[-0.44, 0, 0], [-0.3, -0.1, 0]],
                [[0.1, 0.3, 0], [0, 0.44, 0]],
                [[0, 0.44, 0], [-0.1, 0.3, 0]],
                [[0.1, -0.3, 0], [0, -0.44, 0]],
                [[0, -0.44, 0], [-0.1, -0.3, 0]]
            ];
            const arrowOutlineBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, arrowOutlineBuffer);
            const arrowOutlineVertices = buildLineBuffer(arrowOutlinePairs);
            gl.bufferData(gl.ARRAY_BUFFER, arrowOutlineVertices, gl.STATIC_DRAW);
            const arrowOutlineVertexCount = arrowOutlineVertices.length / 5;

            const positionLocation = gl.getAttribLocation(program, 'position');
            const uvLocation = gl.getAttribLocation(program, 'uv');
            const normalLocation = gl.getAttribLocation(program, 'normal');
            const projectionLocation = gl.getUniformLocation(program, 'uProjection');
            const viewLocation = gl.getUniformLocation(program, 'uView');
            const modelLocation = gl.getUniformLocation(program, 'uModel');
            const colorLocation = gl.getUniformLocation(program, 'uColor');
            const checkerLocation = gl.getUniformLocation(program, 'uUseChecker');
            const useTextureLocation = gl.getUniformLocation(program, 'uUseTexture');
            const useNormalLocation = gl.getUniformLocation(program, 'uUseNormal');
            const useAsgLocation = gl.getUniformLocation(program, 'uUseAsg');
            const useLightingLocation = gl.getUniformLocation(program, 'uUseLighting');
            const useMeshUvLocation = gl.getUniformLocation(program, 'uUseMeshUv');
            const tileLocation = gl.getUniformLocation(program, 'uTile');
            const textureAnchorLocation = gl.getUniformLocation(program, 'uTextureAnchor');
            const objectOriginLocation = gl.getUniformLocation(program, 'uObjectOrigin');
            const textureRotInvLocation = gl.getUniformLocation(program, 'uTextureRotInv');
            const textureLocation = gl.getUniformLocation(program, 'uTexture');
            const normalMapLocation = gl.getUniformLocation(program, 'uNormalMap');
            const asgMapLocation = gl.getUniformLocation(program, 'uAsgMap');
            const cameraPosLocation = gl.getUniformLocation(program, 'uCameraPos');
            const alphaLocation = gl.getUniformLocation(program, 'uAlpha');
            gl.activeTexture(gl.TEXTURE0);
            gl.uniform1i(textureLocation, 0);
            gl.activeTexture(gl.TEXTURE1);
            gl.uniform1i(normalMapLocation, 1);
            gl.activeTexture(gl.TEXTURE2);
            gl.uniform1i(asgMapLocation, 2);
            const fallbackTexture = createSolidTexture([120, 120, 120, 255]);
            const neutralNormalTexture = createSolidTexture([128, 128, 255, 255]);
            const neutralAsgTexture = createSolidTexture([255, 255, 255, 255]);
            gl.uniform1i(useMeshUvLocation, 0);
            gl.uniform3fv(textureAnchorLocation, [0, 0, 0]);
            gl.uniform3fv(objectOriginLocation, [0, 0, 0]);
            gl.uniformMatrix3fv(textureRotInvLocation, false, new Float32Array([
                1, 0, 0,
                0, 1, 0,
                0, 0, 1
            ]));
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, fallbackTexture);

            const identityMatrix = new Float32Array([
                1, 0, 0, 0,
                0, 1, 0, 0,
                0, 0, 1, 0,
                0, 0, 0, 1
            ]);

            Object.assign(camera, {
                position: new Float32Array([0, 2, 20]),
                yaw: 0,
                pitch: 0,
                velocityY: 0,
                baseHeight: 2,
                grounded: true
            });
            const movementVelocity = new Float32Array([0, 0, 0]);
            const playerHalfWidth = 0.5;
            const COLLISION_EPSILON = 0.001;

            function blockAllowsCollision(blockId, crouching) {
                if (!blockId) return true;
                if (blockId === 'flower') return false;
                if (blockId === 'leaf') return !crouching;
                return true;
            }

            function getBlockBounds(block) {
                const half = 0.5 * BLOCK_SCALE;
                return {
                    minX: block.position[0] - half,
                    maxX: block.position[0] + half,
                    minY: block.position[1] - half,
                    maxY: block.position[1] + half,
                    minZ: block.position[2] - half,
                    maxZ: block.position[2] + half
                };
            }

            function getPlayerBounds(position, heightOverride) {
                const height = typeof heightOverride === 'number' ? heightOverride : camera.baseHeight;
                return {
                    minX: position[0] - playerHalfWidth,
                    maxX: position[0] + playerHalfWidth,
                    minY: position[1] - height,
                    maxY: position[1],
                    minZ: position[2] - playerHalfWidth,
                    maxZ: position[2] + playerHalfWidth
                };
            }

            function getPlayerHeight(forCrouchState) {
                const crouched = typeof forCrouchState === 'boolean' ? forCrouchState : crouchState;
                return camera.baseHeight * (crouched ? CROUCH_FACTOR : 1);
            }

            function aabbIntersect(a, b) {
                return (
                    a.minX < b.maxX &&
                    a.maxX > b.minX &&
                    a.minY < b.maxY &&
                    a.maxY > b.minY &&
                    a.minZ < b.maxZ &&
                    a.maxZ > b.minZ
                );
            }

            function canOccupyHeight(topY, height, treatingCrouch) {
                const tempPosition = new Float32Array(camera.position);
                tempPosition[1] = topY;
                const bounds = getPlayerBounds(tempPosition, height);
                for (const block of placedBlocks) {
                    if (!blockAllowsCollision(block.id, treatingCrouch)) continue;
                    const blockBounds = getBlockBounds(block);
                    if (aabbIntersect(bounds, blockBounds)) {
                        return false;
                    }
                }
                return true;
            }

            let jumpHoldActive = false;
            let jumpHoldTimer = 0;

            function setCrouchState(nextState, preserveHead = false) {
                if (nextState === crouchState) {
                    return true;
                }
                const oldHeight = getPlayerHeight(crouchState);
                const newHeight = getPlayerHeight(nextState);
                const delta = newHeight - oldHeight;
                const newTop = preserveHead ? camera.position[1] : camera.position[1] + delta;
                if (delta > 0) {
                    if (!canOccupyHeight(newTop, newHeight, nextState)) {
                        if (preserveHead) {
                            const groundedTop = newHeight;
                            if (!canOccupyHeight(groundedTop, newHeight, nextState)) {
                                return false;
                            }
                            camera.position[1] = groundedTop;
                            camera.velocityY = 0;
                            camera.grounded = true;
                            crouchState = nextState;
                            return true;
                        }
                        return false;
                    }
                }
                camera.position[1] = newTop;
                crouchState = nextState;
                return true;
            }

            function resetJumpSequence() {
                jumpSequenceStage = JumpStages.WAITING_DOWN1;
                jumpSequenceBinding = null;
                lastJumpSignalTime = 0;
            }

            function withinDoubleTapWindow(timestamp) {
                if (!lastJumpSignalTime) return false;
                const diff = timestamp - lastJumpSignalTime;
                return diff >= settings.doubleTapMin && diff <= settings.doubleTapMax;
            }

            function handleJumpSignal(type, binding) {
                if (!binding) return;
                const now = performance.now();
                switch (jumpSequenceStage) {
                    case JumpStages.WAITING_DOWN1:
                        if (type === 'down') {
                            jumpSequenceStage = JumpStages.WAITING_UP1;
                            jumpSequenceBinding = binding;
                            lastJumpSignalTime = now;
                        }
                        break;
                    case JumpStages.WAITING_UP1:
                        if (type !== 'up' || binding !== jumpSequenceBinding || !withinDoubleTapWindow(now)) {
                            resetJumpSequence();
                        } else {
                            jumpSequenceStage = JumpStages.WAITING_DOWN2;
                            lastJumpSignalTime = now;
                        }
                        break;
                    case JumpStages.WAITING_DOWN2:
                        if (type !== 'down' || binding !== jumpSequenceBinding || !withinDoubleTapWindow(now)) {
                            resetJumpSequence();
                        } else {
                            setFlying(!isFlying);
                            resetJumpSequence();
                        }
                        break;
                    default:
                        resetJumpSequence();
                        break;
                }
            }

            function setFlying(active) {
                if (isFlying === active) {
                    return;
                }
                resetJumpSequence();
                isFlying = active;
                if (!isFlying) {
                    movementVelocity[1] = 0;
                }
                if (isFlying) {
                    setCrouchState(false);
                    camera.grounded = false;
                    camera.velocityY = Math.max(0, camera.velocityY);
                    const standHeight = getPlayerHeight(false);
                    if (camera.position[1] <= standHeight) {
                        camera.position[1] = standHeight + 0.1;
                    }
                }
            }

            Object.assign(settings, { doubleTapMin: 50, doubleTapMax: 150 });
            let lookDirection = [0, 0, 1];
            const placedBlocks = [];
            const blockLookup = new Map();
            const objectGroups = new Map();
            let nextObjectGroupId = 1;
            let highlightInfo = null;
            let axisModeIndex = 0;
            let dragState = null;
            let hoverPlacementCell = null;
            let hoverRemovalCell = null;
            let placementPreviewCells = [];
            let removalPreviewCells = [];
            let hoverPreviewCells = [];
            let hoverPreviewWorldCells = [];
            let placementPreviewWorldCells = [];
            let removalPreviewWorldCells = [];
            const pointerButtons = { left: false, right: false };
            let dragCancelLock = false;
            let placementHoldState = null;
            let placementPreviewNormal = null;
            let breakHoldState = null;

            function gridKey(x, y, z) {
                return `${x}|${y}|${z}`;
            }

            function gridToWorld(gridPos) {
                return [
                    (gridPos[0] + 0.5) * BLOCK_SCALE,
                    (gridPos[1] + 0.5) * BLOCK_SCALE,
                    (gridPos[2] + 0.5) * BLOCK_SCALE
                ];
            }

            function rotateSize(size, orientation) {
                // Determine basis vectors for forward/up and compute right as cross.
                const f = orientation.forward;
                const u = orientation.up;
                const r = [
                    u[1] * f[2] - u[2] * f[1],
                    u[2] * f[0] - u[0] * f[2],
                    u[0] * f[1] - u[1] * f[0]
                ];
                const axes = [r, u, f];
                const dims = [size.x, size.y, size.z];
                const extents = [0, 0, 0];
                for (let i = 0; i < 3; i++) {
                    extents[0] += Math.abs(axes[i][0]) * dims[i];
                    extents[1] += Math.abs(axes[i][1]) * dims[i];
                    extents[2] += Math.abs(axes[i][2]) * dims[i];
                }
                return { x: extents[0], y: extents[1], z: extents[2] };
            }

            function getMultiBlockCells(anchor, itemId, surfaceNormal, orientationOverride) {
                const def = getMultiBlockDefinition(itemId);
                if (!def) return [];
                const orientIndex = typeof orientationOverride === 'number' ? orientationOverride : (objectOrientationIndex.get(itemId) || 0);
                const orientation = ORIENTATIONS[orientIndex];
                const f = orientation.forward;
                const u = orientation.up;
                const r = [
                    u[1] * f[2] - u[2] * f[1],
                    u[2] * f[0] - u[0] * f[2],
                    u[0] * f[1] - u[1] * f[0]
                ];
                const dims = [
                    def.size.x || 1,
                    def.size.y || 1,
                    def.size.z || 1
                ];
                const offsets = [];
                for (let x = 0; x < dims[0]; x++) {
                    for (let y = 0; y < dims[1]; y++) {
                        for (let z = 0; z < dims[2]; z++) {
                            offsets.push([
                                x * r[0] + y * u[0] + z * f[0],
                                x * r[1] + y * u[1] + z * f[1],
                                x * r[2] + y * u[2] + z * f[2]
                            ]);
                        }
                    }
                }
                let alignedOffsets = offsets;
                if (surfaceNormal && (surfaceNormal[0] || surfaceNormal[1] || surfaceNormal[2])) {
                    const n = surfaceNormal;
                    let minProj = Infinity;
                    alignedOffsets.forEach(off => {
                        const proj = off[0] * n[0] + off[1] * n[1] + off[2] * n[2];
                        if (proj < minProj) minProj = proj;
                    });
                    if (minProj < 0) {
                        const shift = -minProj;
                        alignedOffsets = alignedOffsets.map(off => [
                            off[0] + n[0] * shift,
                            off[1] + n[1] * shift,
                            off[2] + n[2] * shift
                        ]);
                    }
                }
                return alignedOffsets.map(off => [
                    anchor[0] + off[0],
                    anchor[1] + off[1],
                    anchor[2] + off[2]
                ]);
            }

            function worldToGrid(position) {
                return [
                    position[0] * INV_BLOCK_SCALE,
                    position[1] * INV_BLOCK_SCALE,
                    position[2] * INV_BLOCK_SCALE
                ];
            }

            function snapGrid(position) {
                return [
                    Math.floor(position[0]),
                    Math.floor(position[1]),
                    Math.floor(position[2])
                ];
            }

            function triggerExplosion(centerGrid, itemId) {
                const canDef = getCanisterDefinition(itemId);
                const power = canDef ? canDef.explosionPower || 8 : 8;
                const radius = canDef ? canDef.explosionRadius || 3 : 3;
                const directions = [];
                for (let x = -1; x <= 1; x++) {
                    for (let y = -1; y <= 1; y++) {
                        for (let z = -1; z <= 1; z++) {
                            if (x === 0 && y === 0 && z === 0) continue;
                            directions.push([x, y, z]);
                        }
                    }
                }
                const toRemove = new Map();
                directions.forEach(dir => {
                    let remaining = power;
                    for (let step = 0; step <= radius; step++) {
                        const cell = [
                            centerGrid[0] + dir[0] * step,
                            centerGrid[1] + dir[1] * step,
                            centerGrid[2] + dir[2] * step
                        ];
                        const dist = Math.sqrt(dir[0] * dir[0] + dir[1] * dir[1] + dir[2] * dir[2]) * step;
                        const falloff = Math.max(0, 1 - (dist / radius));
                        const damage = Math.max(0, remaining * falloff);
                        if (damage <= 0.01) break;
                        const block = getBlockAtGrid(cell);
                        if (block) {
                            let durability = getDurability(block.id);
                            if (isFlammable(block.id)) {
                                durability *= 0.5;
                            }
                            if (damage > durability) {
                                const leftover = damage - durability;
                                toRemove.set(block.key, block);
                                remaining = leftover;
                                if (remaining <= 0.01) break;
                            } else {
                                remaining = 0;
                                break;
                            }
                        }
                    }
                });
                toRemove.forEach(block => {
                    removeBlock(block, false);
                });
                const explosionCenterWorld = gridToWorld(centerGrid);
                const radiusWorld = radius * BLOCK_SCALE;
                worldObjects.forEach(obj => {
                    if (!obj.blocks || !obj.blocks.length) return;
                    const comWorld = worldObjectBlockWorldPosition(obj, { offset: obj.com || [0, 0, 0] });
                    const dirVec = [
                        comWorld[0] - explosionCenterWorld[0],
                        comWorld[1] - explosionCenterWorld[1],
                        comWorld[2] - explosionCenterWorld[2]
                    ];
                    const dist = Math.hypot(dirVec[0], dirVec[1], dirVec[2]);
                    if (!dist || dist > radiusWorld) return;
                    const strength = (1 - dist / radiusWorld) * power * 0.5;
                    const impulse = dist > 1e-5 ? [
                        (dirVec[0] / dist) * strength,
                        (dirVec[1] / dist) * strength + strength * 0.25,
                        (dirVec[2] / dist) * strength
                    ] : [0, strength * 0.5, 0];
                    applyImpulseToObject(obj, impulse);
                });
                supportDirty = true;
            }

            function getBlockAtGrid(gridPos) {
                return blockLookup.get(gridKey(gridPos[0], gridPos[1], gridPos[2]));
            }

            function worldObjectBlockWorldPosition(obj, block) {
                // offset is block-center in local block units; rotate from object frame to world
                const local = [
                    (block.offset[0]) * BLOCK_SCALE,
                    (block.offset[1]) * BLOCK_SCALE,
                    (block.offset[2]) * BLOCK_SCALE
                ];
                const rotated = rotateVecByQuat(local, obj.rotation);
                return [
                    obj.origin[0] + rotated[0],
                    obj.origin[1] + rotated[1],
                    obj.origin[2] + rotated[2]
                ];
            }

            function worldObjectBlockAabb(obj, block) {
                const corners = [
                    [block.offset[0] - 0.5, block.offset[1] - 0.5, block.offset[2] - 0.5],
                    [block.offset[0] + 0.5, block.offset[1] - 0.5, block.offset[2] - 0.5],
                    [block.offset[0] - 0.5, block.offset[1] + 0.5, block.offset[2] - 0.5],
                    [block.offset[0] - 0.5, block.offset[1] - 0.5, block.offset[2] + 0.5],
                    [block.offset[0] + 0.5, block.offset[1] + 0.5, block.offset[2] - 0.5],
                    [block.offset[0] + 0.5, block.offset[1] - 0.5, block.offset[2] + 0.5],
                    [block.offset[0] - 0.5, block.offset[1] + 0.5, block.offset[2] + 0.5],
                    [block.offset[0] + 0.5, block.offset[1] + 0.5, block.offset[2] + 0.5]
                ];
                let min = [Infinity, Infinity, Infinity];
                let max = [-Infinity, -Infinity, -Infinity];
                corners.forEach(c => {
                    const local = [
                        (c[0]) * BLOCK_SCALE,
                        (c[1]) * BLOCK_SCALE,
                        (c[2]) * BLOCK_SCALE
                    ];
                    const rotated = rotateVecByQuat(local, obj.rotation);
                    const world = [
                        obj.origin[0] + rotated[0],
                        obj.origin[1] + rotated[1],
                        obj.origin[2] + rotated[2]
                    ];
                    min[0] = Math.min(min[0], world[0]);
                    min[1] = Math.min(min[1], world[1]);
                    min[2] = Math.min(min[2], world[2]);
                    max[0] = Math.max(max[0], world[0]);
                    max[1] = Math.max(max[1], world[1]);
                    max[2] = Math.max(max[2], world[2]);
                });
                if (!isFinite(min[0]) || !isFinite(min[1]) || !isFinite(min[2]) || !isFinite(max[0]) || !isFinite(max[1]) || !isFinite(max[2])) {
                    return null;
                }
                return { min, max };
            }

            function getComWorld(obj) {
                return worldObjectBlockWorldPosition(obj, { offset: obj.com || [0, 0, 0] });
            }

            function getBlockObb(obj, block) {
                const center = worldObjectBlockWorldPosition(obj, block);
                const half = BLOCK_SCALE * 0.5;
                return {
                    center,
                    axes: getQuatAxes(obj.rotation),
                    half: [half, half, half]
                };
            }

            function getStaticBlockObb(gridPos) {
                const center = gridToWorld(gridPos);
                const half = BLOCK_SCALE * 0.5;
                return {
                    center,
                    axes: [[1, 0, 0], [0, 1, 0], [0, 0, 1]],
                    half: [half, half, half]
                };
            }

            function getObbCorners(obb) {
                const hx = obb.half[0];
                const hy = obb.half[1];
                const hz = obb.half[2];
                const ax = obb.axes[0];
                const ay = obb.axes[1];
                const az = obb.axes[2];
                const corners = [];
                const signs = [-1, 1];
                for (let i = 0; i < 2; i++) {
                    for (let j = 0; j < 2; j++) {
                        for (let k = 0; k < 2; k++) {
                            const sx = signs[i];
                            const sy = signs[j];
                            const sz = signs[k];
                            corners.push([
                                obb.center[0] + ax[0] * hx * sx + ay[0] * hy * sy + az[0] * hz * sz,
                                obb.center[1] + ax[1] * hx * sx + ay[1] * hy * sy + az[1] * hz * sz,
                                obb.center[2] + ax[2] * hx * sx + ay[2] * hy * sy + az[2] * hz * sz
                            ]);
                        }
                    }
                }
                return corners;
            }

            function pointInObb(point, obb) {
                const d = subtract(point, obb.center);
                for (let i = 0; i < 3; i++) {
                    const dist = dot(d, obb.axes[i]);
                    if (Math.abs(dist) > obb.half[i] + 1e-6) {
                        return false;
                    }
                }
                return true;
            }

            function obbIntersection(obbA, obbB) {
                const EPS = 1e-6;
                const A = obbA.axes;
                const B = obbB.axes;
                const a = obbA.half;
                const b = obbB.half;
                const R = [
                    [dot(A[0], B[0]), dot(A[0], B[1]), dot(A[0], B[2])],
                    [dot(A[1], B[0]), dot(A[1], B[1]), dot(A[1], B[2])],
                    [dot(A[2], B[0]), dot(A[2], B[1]), dot(A[2], B[2])]
                ];
                const absR = [
                    [Math.abs(R[0][0]) + EPS, Math.abs(R[0][1]) + EPS, Math.abs(R[0][2]) + EPS],
                    [Math.abs(R[1][0]) + EPS, Math.abs(R[1][1]) + EPS, Math.abs(R[1][2]) + EPS],
                    [Math.abs(R[2][0]) + EPS, Math.abs(R[2][1]) + EPS, Math.abs(R[2][2]) + EPS]
                ];
                const tVec = subtract(obbB.center, obbA.center);
                const t = [dot(tVec, A[0]), dot(tVec, A[1]), dot(tVec, A[2])];
                let minPen = Infinity;
                let bestAxis = null;

                for (let i = 0; i < 3; i++) {
                    const ra = a[i];
                    const rb = b[0] * absR[i][0] + b[1] * absR[i][1] + b[2] * absR[i][2];
                    const dist = Math.abs(t[i]);
                    const pen = ra + rb - dist;
                    if (pen < 0) return null;
                    if (pen < minPen) {
                        minPen = pen;
                        const sign = t[i] >= 0 ? 1 : -1;
                        bestAxis = scaleVec(A[i], sign);
                    }
                }

                for (let i = 0; i < 3; i++) {
                    const ra = a[0] * absR[0][i] + a[1] * absR[1][i] + a[2] * absR[2][i];
                    const rb = b[i];
                    const dist = Math.abs(t[0] * R[0][i] + t[1] * R[1][i] + t[2] * R[2][i]);
                    const pen = ra + rb - dist;
                    if (pen < 0) return null;
                    if (pen < minPen) {
                        minPen = pen;
                        const sign = dot(tVec, B[i]) >= 0 ? 1 : -1;
                        bestAxis = scaleVec(B[i], sign);
                    }
                }

                for (let i = 0; i < 3; i++) {
                    for (let j = 0; j < 3; j++) {
                        const axis = cross(A[i], B[j]);
                        const axisLen = Math.hypot(axis[0], axis[1], axis[2]);
                        if (axisLen < EPS) continue;
                        const ra = a[(i + 1) % 3] * absR[(i + 2) % 3][j] + a[(i + 2) % 3] * absR[(i + 1) % 3][j];
                        const rb = b[(j + 1) % 3] * absR[i][(j + 2) % 3] + b[(j + 2) % 3] * absR[i][(j + 1) % 3];
                        const dist = Math.abs(t[(i + 2) % 3] * R[(i + 1) % 3][j] - t[(i + 1) % 3] * R[(i + 2) % 3][j]);
                        const pen = ra + rb - dist;
                        if (pen < 0) return null;
                        if (pen < minPen) {
                            minPen = pen;
                            const normal = scaleVec(axis, 1 / axisLen);
                            const sign = dot(tVec, normal) >= 0 ? 1 : -1;
                            bestAxis = scaleVec(normal, sign);
                        }
                    }
                }

                if (!bestAxis) return null;
                return { normal: normalizeVec(bestAxis), penetration: minPen };
            }

            function collectContactPoints(obbA, obbB) {
                const points = [];
                const cornersA = getObbCorners(obbA);
                const cornersB = getObbCorners(obbB);
                cornersA.forEach(p => {
                    if (pointInObb(p, obbB)) points.push(p);
                });
                cornersB.forEach(p => {
                    if (pointInObb(p, obbA)) points.push(p);
                });
                const unique = [];
                points.forEach(p => {
                    const exists = unique.some(u => Math.hypot(u[0] - p[0], u[1] - p[1], u[2] - p[2]) < CONTACT_MERGE_EPS);
                    if (!exists) unique.push(p);
                });
                return unique;
            }

            function collectPlaneContacts(obb, planeNormal, planeOffset) {
                const corners = getObbCorners(obb);
                let minDist = Infinity;
                corners.forEach(p => {
                    const dist = dot(planeNormal, p) - planeOffset;
                    minDist = Math.min(minDist, dist);
                });
                if (minDist >= 0) return [];
                const contacts = [];
                corners.forEach(p => {
                    const dist = dot(planeNormal, p) - planeOffset;
                    if (dist <= minDist + 1e-4) {
                        contacts.push({
                            point: [
                                p[0] - planeNormal[0] * dist,
                                p[1] - planeNormal[1] * dist,
                                p[2] - planeNormal[2] * dist
                            ],
                            penetration: -dist
                        });
                    }
                });
                return contacts;
            }

            function updateInertiaWorld(obj) {
                if (!obj || !obj.invInertiaLocal) return;
                const rot = quatToMat3(obj.rotation);
                const rotT = mat3Transpose(rot);
                obj.invInertiaWorld = mat3Multiply(mat3Multiply(rot, obj.invInertiaLocal), rotT);
            }

            function integrateOrientation(quat, angularVelocity, dt) {
                const omegaQuat = [angularVelocity[0], angularVelocity[1], angularVelocity[2], 0];
                const dq = quatMultiply(omegaQuat, quat);
                return quatNormalize([
                    quat[0] + 0.5 * dq[0] * dt,
                    quat[1] + 0.5 * dq[1] * dt,
                    quat[2] + 0.5 * dq[2] * dt,
                    quat[3] + 0.5 * dq[3] * dt
                ]);
            }

            function convexHull2D(points) {
                if (points.length <= 1) return points.slice();
                const sorted = points.slice().sort((a, b) => (a[0] === b[0] ? a[1] - b[1] : a[0] - b[0]));
                const cross2 = (o, a, b) => (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0]);
                const lower = [];
                for (const p of sorted) {
                    while (lower.length >= 2 && cross2(lower[lower.length - 2], lower[lower.length - 1], p) <= 0) {
                        lower.pop();
                    }
                    lower.push(p);
                }
                const upper = [];
                for (let i = sorted.length - 1; i >= 0; i--) {
                    const p = sorted[i];
                    while (upper.length >= 2 && cross2(upper[upper.length - 2], upper[upper.length - 1], p) <= 0) {
                        upper.pop();
                    }
                    upper.push(p);
                }
                upper.pop();
                lower.pop();
                return lower.concat(upper);
            }

            function pointInSupportPolygon(point, polygon) {
                if (!polygon.length) return false;
                if (polygon.length === 1) {
                    return Math.hypot(point[0] - polygon[0][0], point[1] - polygon[0][1]) < CONTACT_SLOP;
                }
                if (polygon.length === 2) {
                    const a = polygon[0];
                    const b = polygon[1];
                    const ab = [b[0] - a[0], b[1] - a[1]];
                    const ap = [point[0] - a[0], point[1] - a[1]];
                    const t = Math.max(0, Math.min(1, (ap[0] * ab[0] + ap[1] * ab[1]) / (ab[0] * ab[0] + ab[1] * ab[1] || 1)));
                    const proj = [a[0] + ab[0] * t, a[1] + ab[1] * t];
                    return Math.hypot(point[0] - proj[0], point[1] - proj[1]) < CONTACT_SLOP;
                }
                let sign = 0;
                for (let i = 0; i < polygon.length; i++) {
                    const a = polygon[i];
                    const b = polygon[(i + 1) % polygon.length];
                    const cross = (b[0] - a[0]) * (point[1] - a[1]) - (b[1] - a[1]) * (point[0] - a[0]);
                    if (cross === 0) continue;
                    const s = Math.sign(cross);
                    if (sign === 0) sign = s;
                    if (sign !== s) return false;
                }
                return true;
            }

            function worldToObjectLocal(obj, worldPos) {
                const rel = [
                    worldPos[0] - obj.origin[0],
                    worldPos[1] - obj.origin[1],
                    worldPos[2] - obj.origin[2]
                ];
                return rotateVecByQuatInv(rel, obj.rotation).map(v => v / BLOCK_SCALE);
            }

            function getObjectBlockAtLocal(obj, cell) {
                if (!obj || !obj.blocks) return null;
                const cx = Math.round(cell[0]);
                const cy = Math.round(cell[1]);
                const cz = Math.round(cell[2]);
                for (let i = 0; i < obj.blocks.length; i++) {
                    const b = obj.blocks[i];
                    if (Math.round(b.offset[0]) === cx && Math.round(b.offset[1]) === cy && Math.round(b.offset[2]) === cz) {
                        return { block: b, index: i };
                    }
                }
                return null;
            }

            function localCellToWorld(obj, cell) {
                const local = [
                    (cell[0]) * BLOCK_SCALE,
                    (cell[1]) * BLOCK_SCALE,
                    (cell[2]) * BLOCK_SCALE
                ];
                const rotated = rotateVecByQuat(local, obj.rotation);
                return [
                    obj.origin[0] + rotated[0],
                    obj.origin[1] + rotated[1],
                    obj.origin[2] + rotated[2]
                ];
            }

            function rayBoxIntersect(origin, dir, min, max) {
                const EPS = 1e-6;
                let tmin = -Infinity;
                let tmax = Infinity;
                let hitNormal = [0, 0, 0];
                for (let i = 0; i < 3; i++) {
                    const invD = Math.abs(dir[i]) < EPS ? 0 : 1 / dir[i];
                    let t1, t2;
                    if (invD !== 0) {
                        t1 = (min[i] - origin[i]) * invD;
                        t2 = (max[i] - origin[i]) * invD;
                        if (t1 > t2) [t1, t2] = [t2, t1];
                        if (t1 > tmin) {
                            tmin = t1;
                            hitNormal = [0, 0, 0];
                            hitNormal[i] = dir[i] > 0 ? -1 : 1;
                        }
                        tmin = Math.max(tmin, t1);
                        tmax = Math.min(tmax, t2);
                        if (tmax < tmin) return null;
                    } else {
                        // Ray parallel to slab; must be within slab to intersect
                        if (origin[i] < min[i] || origin[i] > max[i]) return null;
                    }
                }
                if (tmax < 0) return null;
                const tHit = tmin >= 0 ? tmin : tmax;
                return { t: tHit, normal: hitNormal };
            }

            function rayAabbLocal(origin, dir, min, max) {
                // origin/dir in local space of the OBB (axis-aligned unit cube), returns t and normal in local space
                const EPS = 1e-6;
                let tmin = -Infinity;
                let tmax = Infinity;
                let hitNormal = [0, 0, 0];
                for (let i = 0; i < 3; i++) {
                    const invD = Math.abs(dir[i]) < EPS ? 0 : 1 / dir[i];
                    let t1, t2;
                    if (invD !== 0) {
                        t1 = (min[i] - origin[i]) * invD;
                        t2 = (max[i] - origin[i]) * invD;
                        if (t1 > t2) [t1, t2] = [t2, t1];
                        if (t1 > tmin) {
                            tmin = t1;
                            hitNormal = [0, 0, 0];
                            hitNormal[i] = dir[i] > 0 ? -1 : 1;
                        }
                        tmin = Math.max(tmin, t1);
                        tmax = Math.min(tmax, t2);
                        if (tmax < tmin) return null;
                    } else {
                        if (origin[i] < min[i] || origin[i] > max[i]) return null;
                    }
                }
                if (tmax < 0) return null;
                return { t: tmin >= 0 ? tmin : tmax, normal: hitNormal };
            }

            function raycastWorldObjects(origin, dir) {
                let best = null;
                worldObjects.forEach(obj => {
                    // Transform ray into object local space (blocks) and keep t in world units
                    const localOrigin = worldToObjectLocal(obj, origin);
                    const localDir = normalizeVec(rotateVecByQuatInv(dir, obj.rotation));
                    const len = Math.abs(localDir[0]) + Math.abs(localDir[1]) + Math.abs(localDir[2]);
                    if (len < 1e-6) return;
                    for (let i = 0; i < obj.blocks.length; i++) {
                        const b = obj.blocks[i];
                        const min = [b.offset[0] - 0.5, b.offset[1] - 0.5, b.offset[2] - 0.5];
                        const max = [b.offset[0] + 0.5, b.offset[1] + 0.5, b.offset[2] + 0.5];
                        const hit = rayAabbLocal(localOrigin, localDir, min, max);
                        if (!hit) continue;
                        if (hit.t <= MAX_INTERACT_DISTANCE) {
                            if (!best || hit.t < best.distance) {
                                const gridPos = [
                                    Math.round(b.offset[0]),
                                    Math.round(b.offset[1]),
                                    Math.round(b.offset[2])
                                ];
                                best = {
                                    type: 'block',
                                    position: gridPos,
                                    block: {
                                        ...b,
                                        grid: gridPos.slice(),
                                        key: gridKey(gridPos[0], gridPos[1], gridPos[2])
                                    },
                                    normal: hit.normal.slice(), // local-space normal
                                    distance: hit.t,
                                    layer: 'object',
                                    obj,
                                    blockIndex: i
                                };
                            }
                        }
                    }
                });
                return best;
            }

            function compareGrid(a, b) {
                if (a[0] !== b[0]) return a[0] - b[0];
                if (a[1] !== b[1]) return a[1] - b[1];
                return a[2] - b[2];
            }

            function isTransparentBlock(block) {
                if (!block) return false;
                const def = getItemDef(block.id);
                if (!def) return false;
                return def.isGlass || (typeof def.opacity === 'number' && def.opacity < 1);
            }

            function isSeeThroughBlock(block) {
                if (!block) return false;
                const def = getItemDef(block.id);
                return !!(def && def.isSeeThrough);
            }

            function isCanisterItem(itemId) {
                const def = getItemDef(itemId);
                return !!(def && def.isCanister);
            }

            function getCanisterDefinition(itemId) {
                if (!itemId) return null;
                return objectDefinitions.get(itemId) || null;
            }

            function getGroupAnchorAndOrientation(block) {
                if (!block || !block.groupId || !objectGroups.has(block.groupId)) {
                    return {
                        anchor: block ? block.grid.slice() : [0, 0, 0],
                        orientationIndex: objectOrientationIndex.get(block ? block.id : null) || 0,
                        anchorKey: block ? block.key : null,
                        cells: block ? [block.grid.slice()] : []
                    };
                }
                const group = objectGroups.get(block.groupId);
                return {
                    anchor: group.anchor ? group.anchor.slice() : (block ? block.grid.slice() : [0, 0, 0]),
                    orientationIndex: typeof group.orientationIndex === 'number' ? group.orientationIndex : (objectOrientationIndex.get(block.id) || 0),
                    anchorKey: group.anchorKey || (block ? block.key : null),
                    cells: group.cells ? group.cells.map(c => c.slice()) : (block ? [block.grid.slice()] : [])
                };
            }

            function getCanisterMesh(entryId) {
                const entry = canisterMeshCache.get(entryId);
                if (entry && entry.status === 'ready') {
                    return entry.data;
                }
                return null;
            }

            async function ensureCanisterMesh(itemId) {
                const def = getCanisterDefinition(itemId);
                if (!def || !def.meshPath) return null;
                const existing = canisterMeshCache.get(itemId);
                if (existing) {
                    if (existing.status === 'ready') return existing.data;
                    return null;
                }
                const loader = new FBXLoader();
                const entry = { status: 'loading', data: null, promise: null };
                canisterMeshCache.set(itemId, entry);
                entry.promise = loader.loadAsync(def.meshPath).then(object => {
                    const mesh = buildMeshBuffersFromObject(object, def.size);
                    entry.status = mesh ? 'ready' : 'error';
                    entry.data = mesh;
                    return mesh;
                }).catch(error => {
                    console.error('Failed to load canister mesh:', def.meshPath, error);
                    entry.status = 'error';
                    return null;
                });
                return entry.promise;
            }

            function buildMeshBuffersFromObject(object, size) {
                if (!object) return null;
                object.updateMatrixWorld(true);
                const positions = [];
                const normals = [];
                const uvs = [];
                const indices = [];
                let vertexOffset = 0;
                const bboxMin = [Infinity, Infinity, Infinity];
                const bboxMax = [-Infinity, -Infinity, -Infinity];
                const tempV = new THREE.Vector3();
                const tempN = new THREE.Vector3();
                const normalMat = new THREE.Matrix3();
                object.traverse(child => {
                    if (!child.isMesh || !child.geometry) return;
                    const geom = child.geometry;
                    const posAttr = geom.getAttribute('position');
                    if (!posAttr) return;
                    const normAttr = geom.getAttribute('normal');
                    const uvAttr = geom.getAttribute('uv');
                    const idxAttr = geom.index ? geom.index.array : null;
                    normalMat.getNormalMatrix(child.matrixWorld);
                    for (let i = 0; i < posAttr.count; i++) {
                        tempV.fromBufferAttribute(posAttr, i).applyMatrix4(child.matrixWorld);
                        bboxMin[0] = Math.min(bboxMin[0], tempV.x);
                        bboxMin[1] = Math.min(bboxMin[1], tempV.y);
                        bboxMin[2] = Math.min(bboxMin[2], tempV.z);
                        bboxMax[0] = Math.max(bboxMax[0], tempV.x);
                        bboxMax[1] = Math.max(bboxMax[1], tempV.y);
                        bboxMax[2] = Math.max(bboxMax[2], tempV.z);
                        positions.push(tempV.x, tempV.y, tempV.z);
                        if (normAttr) {
                            tempN.fromBufferAttribute(normAttr, i).applyMatrix3(normalMat).normalize();
                            normals.push(tempN.x, tempN.y, tempN.z);
                        } else {
                            normals.push(0, 1, 0);
                        }
                        if (uvAttr) {
                            uvs.push(uvAttr.getX(i), uvAttr.getY(i));
                        } else {
                            uvs.push(0, 0);
                        }
                    }
                    const vertCount = posAttr.count;
                    if (idxAttr) {
                        for (let i = 0; i < idxAttr.length; i++) {
                            indices.push(idxAttr[i] + vertexOffset);
                        }
                    } else {
                        for (let i = 0; i < vertCount; i++) {
                            indices.push(vertexOffset + i);
                        }
                    }
                    vertexOffset += vertCount;
                });
                if (!positions.length || !indices.length) {
                    return null;
                }
                const targetSize = {
                    x: (size && size.x ? size.x : 1) * BLOCK_SCALE,
                    y: (size && size.y ? size.y : 1) * BLOCK_SCALE,
                    z: (size && size.z ? size.z : 1) * BLOCK_SCALE
                };
                const bboxSize = [
                    Math.max(bboxMax[0] - bboxMin[0], 0.0001),
                    Math.max(bboxMax[1] - bboxMin[1], 0.0001),
                    Math.max(bboxMax[2] - bboxMin[2], 0.0001)
                ];
                const scale = [
                    targetSize.x / bboxSize[0],
                    targetSize.y / bboxSize[1],
                    targetSize.z / bboxSize[2]
                ];
                for (let i = 0; i < positions.length; i += 3) {
                    positions[i] = (positions[i] - bboxMin[0]) * scale[0];
                    positions[i + 1] = (positions[i + 1] - bboxMin[1]) * scale[1];
                    positions[i + 2] = (positions[i + 2] - bboxMin[2]) * scale[2];
                }
                const positionBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
                const normalBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normals), gl.STATIC_DRAW);
                const uvBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, uvBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(uvs), gl.STATIC_DRAW);
                const useUint = (positions.length / 3) > 65535 && uintElementExt;
                const indexArray = useUint ? new Uint32Array(indices) : new Uint16Array(indices);
                const indexBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indexArray, gl.STATIC_DRAW);
                return {
                    positionBuffer,
                    normalBuffer,
                    uvBuffer,
                    indexBuffer,
                    indexCount: indexArray.length,
                    indexType: useUint ? gl.UNSIGNED_INT : gl.UNSIGNED_SHORT
                };
            }

            function isMultiBlockItem(itemId) {
                const def = getItemDef(itemId);
                if (!def) return false;
                if (def.isMultiBlock) return true;
                const objDef = objectDefinitions.get(itemId);
                if (objDef && objDef.size) {
                    const sz = objDef.size;
                    return (sz.x || 1) > 1 || (sz.y || 1) > 1 || (sz.z || 1) > 1;
                }
                return false;
            }

            function getMultiBlockDefinition(itemId) {
                if (!itemId) return null;
                const def = objectDefinitions.get(itemId);
                if (def && def.size) return def;
                return null;
            }

            function getDurability(itemId) {
                const def = getItemDef(itemId);
                if (!def) return 1;
                if (def.raw && def.raw.ratings && typeof def.raw.ratings.durability === 'number') {
                    return def.raw.ratings.durability;
                }
                if (def.ratings && typeof def.ratings.durability === 'number') {
                    return def.ratings.durability;
                }
                return 1;
            }

            function isFlammable(itemId) {
                const def = getItemDef(itemId);
                return !!(def && def.flammable);
            }

            function isSupportNode(itemId) {
                const def = getItemDef(itemId);
                if (!def || !def.raw) return false;
                const name = (def.raw.name || '').toLowerCase();
                return name.includes('propanetank');
            }

            function getRatings(itemId) {
                const def = getItemDef(itemId);
                if (!def) return {};
                if (def.raw && def.raw.ratings) return def.raw.ratings;
                return def.ratings || {};
            }

            function getWeight(itemId) {
                const ratings = getRatings(itemId);
                if (typeof ratings.density === 'number') return Math.max(0, ratings.density);
                return 1;
            }

            function getFriction(itemId) {
                const ratings = getRatings(itemId);
                if (typeof ratings.friction === 'number') return Math.max(0, ratings.friction);
                return 1;
            }

            function getRestitution(itemId) {
                const ratings = getRatings(itemId);
                if (typeof ratings.restitution === 'number') {
                    return Math.max(0, Math.min(1, ratings.restitution));
                }
                return 0.1;
            }

            function getBuoyancy(itemId) {
                const ratings = getRatings(itemId);
                if (typeof ratings.buoyancy === 'number') return Math.max(0, ratings.buoyancy);
                return 0;
            }

            function addBlockAt(gridPos, itemId) {
                const def = getItemDef(itemId);
                const color = def && Array.isArray(def.color) ? def.color : [0.6, 0.6, 0.6];
                const block = {
                    id: itemId,
                    grid: gridPos.slice(),
                    position: gridToWorld(gridPos),
                    color,
                    key: gridKey(gridPos[0], gridPos[1], gridPos[2])
                };
                blockLookup.set(block.key, block);
                placedBlocks.push(block);
                supportDirty = true;
            }

            function placeMultiBlockAt(anchor, itemId, surfaceNormal) {
                const def = getMultiBlockDefinition(itemId);
                if (!def) return false;
                const orientIndex = objectOrientationIndex.get(itemId) || 0;
                const cells = getMultiBlockCells(anchor, itemId, surfaceNormal, orientIndex);
                if (!cells.length) return false;
                for (const cell of cells) {
                    const existing = getBlockAtGrid(cell);
                    if (existing) {
                        return false;
                    }
                }
                const groupId = nextObjectGroupId++;
                objectDefinitions.set(itemId, {
                    ...def
                });
                objectGroups.set(groupId, {
                    itemId,
                    cells: cells.map(c => c.slice()),
                    anchor: anchor.slice(),
                    anchorKey: gridKey(anchor[0], anchor[1], anchor[2]),
                    orientationIndex: orientIndex
                });
                cells.forEach(cell => {
                    const defItem = getItemDef(itemId);
                    const color = defItem && Array.isArray(defItem.color) ? defItem.color : [0.8, 0.2, 0.2];
                    const block = {
                        id: itemId,
                        grid: cell.slice(),
                        position: gridToWorld(cell),
                        color,
                        key: gridKey(cell[0], cell[1], cell[2]),
                        groupId
                    };
                    blockLookup.set(block.key, block);
                    placedBlocks.push(block);
                });
                supportDirty = true;
                return true;
            }

            const explodingGroups = new Set();

            function removeGroup(groupId) {
                if (!groupId || !objectGroups.has(groupId)) return;
                const group = objectGroups.get(groupId);
                group.cells.forEach(cell => {
                    const key = gridKey(cell[0], cell[1], cell[2]);
                    const b = blockLookup.get(key);
                    if (b) {
                        blockLookup.delete(key);
                        const idx = placedBlocks.indexOf(b);
                        if (idx !== -1) placedBlocks.splice(idx, 1);
                    }
                });
                objectGroups.delete(groupId);
                supportDirty = true;
            }

            function removeBlock(block, triggerExplosion = true) {
                if (!block) return;
                if (isSupportNode(block.id)) {
                    detachConnectedComponent(block);
                    return;
                }
                if (triggerExplosion && isCanisterItem(block.id)) {
                    const groupKey = block.groupId || block.key;
                    if (!explodingGroups.has(groupKey)) {
                        explodingGroups.add(groupKey);
                        let center = block.grid.slice();
                        if (block.groupId && objectGroups.has(block.groupId)) {
                            const cells = objectGroups.get(block.groupId).cells;
                            const sum = cells.reduce((acc, c) => {
                                acc[0] += c[0]; acc[1] += c[1]; acc[2] += c[2];
                                return acc;
                            }, [0, 0, 0]);
                            center = [
                                sum[0] / cells.length,
                                sum[1] / cells.length,
                                sum[2] / cells.length
                            ];
                        }
                        triggerExplosion(center, block.id);
                        explodingGroups.delete(groupKey);
                    }
                }
                if (block.groupId && objectGroups.has(block.groupId)) {
                    removeGroup(block.groupId);
                } else {
                    blockLookup.delete(block.key);
                    const index = placedBlocks.indexOf(block);
                    if (index !== -1) {
                        placedBlocks.splice(index, 1);
                    }
                    supportDirty = true;
                }
            }

            const NEIGHBOR_OFFSETS = [
                [1, 0, 0], [-1, 0, 0],
                [0, 1, 0], [0, -1, 0],
                [0, 0, 1], [0, 0, -1]
            ];

            function getNeighbors(cell) {
                return NEIGHBOR_OFFSETS.map(dir => [
                    cell[0] + dir[0],
                    cell[1] + dir[1],
                    cell[2] + dir[2]
                ]);
            }

            function collectSupportedKeys() {
                const supported = new Set();
                const queue = [];
                placedBlocks.forEach(block => {
                    if (block.grid[1] === 0) {
                        supported.add(block.key);
                        queue.push(block.grid.slice());
                    }
                });
                while (queue.length) {
                    const cell = queue.shift();
                    getNeighbors(cell).forEach(neighbor => {
                        const block = getBlockAtGrid(neighbor);
                        if (block && !supported.has(block.key)) {
                            supported.add(block.key);
                            queue.push(block.grid.slice());
                        }
                    });
                }
                return supported;
            }

            function detachConnectedComponent(startBlock) {
                if (!startBlock) return;
                const visited = new Set();
                const queue = [startBlock.grid.slice()];
                const component = [];
                while (queue.length) {
                    const cell = queue.shift();
                    const block = getBlockAtGrid(cell);
                    if (!block || visited.has(block.key)) continue;
                    visited.add(block.key);
                    component.push(block);
                    getNeighbors(cell).forEach(neighbor => {
                        const nb = getBlockAtGrid(neighbor);
                        if (nb && !visited.has(nb.key)) {
                            queue.push(neighbor);
                        }
                    });
                }
                if (component.length) {
                    createWorldObject(component);
                }
            }

            function extractComponent(startKey, visited) {
                const component = [];
                const queue = [];
                const startBlock = blockLookup.get(startKey);
                if (!startBlock) return component;
                queue.push(startBlock.grid.slice());
                visited.add(startKey);
                while (queue.length) {
                    const cell = queue.shift();
                    const block = getBlockAtGrid(cell);
                    if (!block) continue;
                    component.push(block);
                    getNeighbors(cell).forEach(neighbor => {
                        const nBlock = getBlockAtGrid(neighbor);
                        if (nBlock && !visited.has(nBlock.key)) {
                            visited.add(nBlock.key);
                            queue.push(nBlock.grid.slice());
                        }
                    });
                }
                return component;
            }

            function computeObjectProperties(blockData) {
                let mass = 0;
                let friction = 0;
                let restitution = 0;
                let buoyancy = 0;
                const com = [0, 0, 0];
                blockData.forEach(b => {
                    const w = Math.max(0.01, getWeight(b.id));
                    mass += w;
                    friction += getFriction(b.id);
                    restitution += getRestitution(b.id);
                    buoyancy += getBuoyancy(b.id);
                    com[0] += w * b.offset[0];
                    com[1] += w * b.offset[1];
                    com[2] += w * b.offset[2];
                });
                const count = blockData.length || 1;
                mass = Math.max(0.01, mass);
                const invMass = 1 / mass;
                com[0] *= invMass;
                com[1] *= invMass;
                com[2] *= invMass;
                const inertia = [0, 0, 0, 0, 0, 0, 0, 0, 0];
                const half = BLOCK_SCALE * 0.5;
                blockData.forEach(b => {
                    const w = Math.max(0.01, getWeight(b.id));
                    const Ixx = (1 / 3) * w * (half * half + half * half);
                    const Iyy = (1 / 3) * w * (half * half + half * half);
                    const Izz = (1 / 3) * w * (half * half + half * half);
                    inertia[0] += Ixx;
                    inertia[4] += Iyy;
                    inertia[8] += Izz;
                    const r = [
                        (b.offset[0] - com[0]) * BLOCK_SCALE,
                        (b.offset[1] - com[1]) * BLOCK_SCALE,
                        (b.offset[2] - com[2]) * BLOCK_SCALE
                    ];
                    const r2 = dot(r, r);
                    inertia[0] += w * (r2 - r[0] * r[0]);
                    inertia[1] += -w * (r[0] * r[1]);
                    inertia[2] += -w * (r[0] * r[2]);
                    inertia[3] += -w * (r[1] * r[0]);
                    inertia[4] += w * (r2 - r[1] * r[1]);
                    inertia[5] += -w * (r[1] * r[2]);
                    inertia[6] += -w * (r[2] * r[0]);
                    inertia[7] += -w * (r[2] * r[1]);
                    inertia[8] += w * (r2 - r[2] * r[2]);
                });
                const invInertia = mat3Invert(inertia);
                return {
                    mass,
                    invMass,
                    inertiaLocal: inertia,
                    invInertiaLocal: invInertia,
                    restitution: restitution / count,
                    staticFriction: friction / count,
                    dynamicFriction: (friction / count) * 0.8,
                    buoyancy: buoyancy / count,
                    com
                };
            }

            function refreshObjectProperties(obj) {
                if (!obj || !obj.blocks) return;
                const props = computeObjectProperties(obj.blocks);
                obj.mass = props.mass;
                obj.invMass = props.invMass;
                obj.inertiaLocal = props.inertiaLocal;
                obj.invInertiaLocal = props.invInertiaLocal;
                obj.restitution = props.restitution;
                obj.staticFriction = props.staticFriction;
                obj.dynamicFriction = props.dynamicFriction;
                obj.buoyancy = props.buoyancy;
                obj.com = props.com;
            }

            function splitWorldObjectIfDisconnected(obj) {
                if (!obj || !obj.blocks || obj.blocks.length < 2) return false;
                const indexMap = new Map();
                obj.blocks.forEach((b, idx) => {
                    const key = gridKey(Math.round(b.offset[0]), Math.round(b.offset[1]), Math.round(b.offset[2]));
                    indexMap.set(key, idx);
                });
                const visited = new Set();
                const components = [];
                const neighborDirs = [
                    [1, 0, 0], [-1, 0, 0],
                    [0, 1, 0], [0, -1, 0],
                    [0, 0, 1], [0, 0, -1]
                ];
                for (const key of indexMap.keys()) {
                    if (visited.has(key)) continue;
                    const queue = [key];
                    const compBlocks = [];
                    visited.add(key);
                    while (queue.length) {
                        const current = queue.pop();
                        const idx = indexMap.get(current);
                        if (typeof idx === 'number') {
                            compBlocks.push(obj.blocks[idx]);
                        }
                        const parts = current.split('|').map(v => parseInt(v, 10));
                        const cx = parts[0], cy = parts[1], cz = parts[2];
                        neighborDirs.forEach(dir => {
                            const nk = gridKey(cx + dir[0], cy + dir[1], cz + dir[2]);
                            if (indexMap.has(nk) && !visited.has(nk)) {
                                visited.add(nk);
                                queue.push(nk);
                            }
                        });
                    }
                    if (compBlocks.length) components.push(compBlocks);
                }
                if (components.length <= 1) return false;
                const idx = worldObjects.indexOf(obj);
                if (idx !== -1) worldObjects.splice(idx, 1);
                const anchorOrigin = obj.textureAnchorLocal
                    ? obj.textureAnchorLocal.slice()
                    : rotateVecByQuatInv(obj.origin, obj.rotation);
                components.forEach(component => {
                    const base = [Infinity, Infinity, Infinity];
                    component.forEach(b => {
                        base[0] = Math.min(base[0], Math.round(b.offset[0]));
                        base[1] = Math.min(base[1], Math.round(b.offset[1]));
                        base[2] = Math.min(base[2], Math.round(b.offset[2]));
                    });
                    const newBlocks = component.map(b => ({
                        id: b.id,
                        color: b.color.slice(),
                        offset: [
                            Math.round(b.offset[0]) - base[0],
                            Math.round(b.offset[1]) - base[1],
                            Math.round(b.offset[2]) - base[2]
                        ]
                    }));
                    const shiftLocal = [
                        base[0] * BLOCK_SCALE,
                        base[1] * BLOCK_SCALE,
                        base[2] * BLOCK_SCALE
                    ];
                    const shiftWorld = rotateVecByQuat(shiftLocal, obj.rotation);
                    const origin = [
                        obj.origin[0] + shiftWorld[0],
                        obj.origin[1] + shiftWorld[1],
                        obj.origin[2] + shiftWorld[2]
                    ];
                    const props = computeObjectProperties(newBlocks);
                    worldObjects.push({
                        origin,
                        rotation: obj.rotation.slice(),
                        velocity: obj.velocity.slice(),
                        angularVelocity: obj.angularVelocity.slice(),
                        com: props.com,
                        blocks: newBlocks,
                        mass: props.mass,
                        invMass: props.invMass,
                        inertiaLocal: props.inertiaLocal,
                        invInertiaLocal: props.invInertiaLocal,
                        invInertiaWorld: props.invInertiaLocal,
                        restitution: props.restitution,
                        staticFriction: props.staticFriction,
                        dynamicFriction: props.dynamicFriction,
                        buoyancy: props.buoyancy,
                        force: [0, 0, 0],
                        torque: [0, 0, 0],
                        groupData: [],
                        physicsState: PHYSICS_STATE.ACTIVE,
                        sleepCounter: 0,
                        localGridOrigin: base.slice(),
                        textureAnchorLocal: [
                            anchorOrigin[0] + shiftLocal[0],
                            anchorOrigin[1] + shiftLocal[1],
                            anchorOrigin[2] + shiftLocal[2]
                        ]
                    });
                });
                return true;
            }

            function removeObjectBlockAt(obj, index) {
                if (!obj || !obj.blocks || index < 0 || index >= obj.blocks.length) return false;
                obj.blocks.splice(index, 1);
                if (!obj.blocks.length) {
                    const remIdx = worldObjects.indexOf(obj);
                    if (remIdx !== -1) worldObjects.splice(remIdx, 1);
                    return true;
                }
                if (splitWorldObjectIfDisconnected(obj)) {
                    return true;
                }
                refreshObjectProperties(obj);
                wakeWorldObject(obj);
                return true;
            }

            function createWorldObject(blocks) {
                if (!blocks.length) return;
                const min = [Infinity, Infinity, Infinity];
                blocks.forEach(block => {
                    min[0] = Math.min(min[0], block.grid[0]);
                    min[1] = Math.min(min[1], block.grid[1]);
                    min[2] = Math.min(min[2], block.grid[2]);
                });
                const baseGrid = min;
                const offsetsKeySet = new Set();
                const groupOffsets = new Map();
                blocks.forEach(block => {
                    const off = [
                        block.grid[0] - baseGrid[0],
                        block.grid[1] - baseGrid[1],
                        block.grid[2] - baseGrid[2]
                    ];
                    offsetsKeySet.add(gridKey(off[0], off[1], off[2]));
                    if (block.groupId) {
                        const sourceGroup = objectGroups.has(block.groupId) ? objectGroups.get(block.groupId) : null;
                        if (!groupOffsets.has(block.groupId)) {
                            groupOffsets.set(block.groupId, {
                                itemId: block.id,
                                offsets: [],
                                orientationIndex: sourceGroup && typeof sourceGroup.orientationIndex === 'number' ? sourceGroup.orientationIndex : 0,
                                anchorOffset: sourceGroup && sourceGroup.anchor ? [
                                    sourceGroup.anchor[0] - baseGrid[0],
                                    sourceGroup.anchor[1] - baseGrid[1],
                                    sourceGroup.anchor[2] - baseGrid[2]
                                ] : [0, 0, 0]
                            });
                        }
                        groupOffsets.get(block.groupId).offsets.push(off);
                    }
                });
                const groupData = Array.from(groupOffsets.values());
                const blockData = blocks.map(block => ({
                    id: block.id,
                    color: block.color.slice(),
                    offset: [
                        block.grid[0] - baseGrid[0],
                        block.grid[1] - baseGrid[1],
                        block.grid[2] - baseGrid[2]
                    ]
                }));
                const origin = gridToWorld(baseGrid);
                const props = computeObjectProperties(blockData);
                const obj = {
                    origin,
                    rotation: [0, 0, 0, 1], // quat
                    velocity: [0, 0, 0],
                    angularVelocity: [0, 0, 0],
                    com: props.com,
                    blocks: blockData,
                    mass: props.mass,
                    invMass: props.invMass,
                    inertiaLocal: props.inertiaLocal,
                    invInertiaLocal: props.invInertiaLocal,
                    invInertiaWorld: props.invInertiaLocal,
                    restitution: props.restitution,
                    staticFriction: props.staticFriction,
                    dynamicFriction: props.dynamicFriction,
                    buoyancy: props.buoyancy,
                    force: [0, 0, 0],
                    torque: [0, 0, 0],
                    groupData,
                    physicsState: PHYSICS_STATE.ACTIVE,
                    sleepCounter: 0,
                    localGridOrigin: baseGrid,
                    textureAnchorLocal: origin.slice()
                };
                blocks.forEach(block => {
                    blockLookup.delete(block.key);
                    const idx = placedBlocks.indexOf(block);
                    if (idx !== -1) placedBlocks.splice(idx, 1);
                    if (block.groupId && objectGroups.has(block.groupId)) {
                        objectGroups.delete(block.groupId);
                    }
                });
                worldObjects.push(obj);
            }

            function checkForUnsupportedComponents() {
                supportDirty = false;
                if (!placedBlocks.length) return;
                const supported = collectSupportedKeys();
                const visited = new Set();
                placedBlocks.forEach(block => {
                    if (visited.has(block.key)) return;
                    const component = extractComponent(block.key, visited);
                    if (!component.length) return;
                    const anchored = component.some(b => supported.has(b.key));
                    if (!anchored) {
                        createWorldObject(component);
                    }
                });
            }

            function updateWorldObjects(delta) {
                if (!worldObjects.length) return;
                const contacts = [];
                const groundContacts = new Map();
                const objectAabbs = new Map();
                const groundMaterial = {
                    restitution: GROUND_RESTITUTION,
                    staticFriction: GROUND_STATIC_FRICTION,
                    dynamicFriction: GROUND_DYNAMIC_FRICTION
                };

                const addContact = (a, b, point, normal, penetration, materialB, isGround) => {
                    if (!a || penetration <= 0) return;
                    const matA = a || {};
                    const matB = materialB || b || {};
                    const restitution = Math.min(matA.restitution || 0, matB.restitution || 0);
                    const staticFriction = Math.sqrt((matA.staticFriction || 0) * (matB.staticFriction || 0));
                    const dynamicFriction = Math.sqrt((matA.dynamicFriction || 0) * (matB.dynamicFriction || 0));
                    contacts.push({
                        a,
                        b,
                        point,
                        normal,
                        penetration,
                        restitution,
                        staticFriction,
                        dynamicFriction,
                        isGround: !!isGround
                    });
                    if (isGround) {
                        if (!groundContacts.has(a)) groundContacts.set(a, []);
                        groundContacts.get(a).push(point);
                    }
                };

                worldObjects.forEach(obj => {
                    if (!obj.blocks.length) return;
                    updateInertiaWorld(obj);
                    if (obj.physicsState === PHYSICS_STATE.ACTIVE) {
                        obj.force = [GRAVITY[0] * obj.mass, GRAVITY[1] * obj.mass, GRAVITY[2] * obj.mass];
                        obj.torque = [0, 0, 0];
                        obj.velocity[0] += obj.force[0] * obj.invMass * delta;
                        obj.velocity[1] += obj.force[1] * obj.invMass * delta;
                        obj.velocity[2] += obj.force[2] * obj.invMass * delta;
                        const angularAccel = mat3MultiplyVec(obj.invInertiaWorld, obj.torque);
                        obj.angularVelocity = add(obj.angularVelocity, scaleVec(angularAccel, delta));
                        obj.origin[0] += obj.velocity[0] * delta;
                        obj.origin[1] += obj.velocity[1] * delta;
                        obj.origin[2] += obj.velocity[2] * delta;
                        obj.rotation = integrateOrientation(obj.rotation, obj.angularVelocity, delta);
                    }
                    obj.comWorld = getComWorld(obj);
                    const objAabb = obj.blocks.reduce((acc, b) => {
                        const aabb = worldObjectBlockAabb(obj, b);
                        if (!aabb) return acc;
                        acc.min[0] = Math.min(acc.min[0], aabb.min[0]);
                        acc.min[1] = Math.min(acc.min[1], aabb.min[1]);
                        acc.min[2] = Math.min(acc.min[2], aabb.min[2]);
                        acc.max[0] = Math.max(acc.max[0], aabb.max[0]);
                        acc.max[1] = Math.max(acc.max[1], aabb.max[1]);
                        acc.max[2] = Math.max(acc.max[2], aabb.max[2]);
                        return acc;
                    }, { min: [Infinity, Infinity, Infinity], max: [-Infinity, -Infinity, -Infinity] });
                    if (isFinite(objAabb.min[0]) && isFinite(objAabb.max[0])) {
                        objectAabbs.set(obj, objAabb);
                    }
                });

                worldObjects.forEach(obj => {
                    if (!obj.blocks.length) return;
                    if (!objectAabbs.has(obj)) return;
                    obj.blocks.forEach(block => {
                        const obb = getBlockObb(obj, block);
                        const planeContacts = collectPlaneContacts(obb, [0, 1, 0], 0);
                        planeContacts.slice(0, 4).forEach(entry => {
                            addContact(obj, null, entry.point, [0, -1, 0], entry.penetration, groundMaterial, true);
                        });

                        const blockAabb = worldObjectBlockAabb(obj, block);
                        if (!blockAabb) return;
                        const minCell = [
                            Math.floor(blockAabb.min[0] * INV_BLOCK_SCALE),
                            Math.floor(blockAabb.min[1] * INV_BLOCK_SCALE),
                            Math.floor(blockAabb.min[2] * INV_BLOCK_SCALE)
                        ];
                        const maxCell = [
                            Math.floor(blockAabb.max[0] * INV_BLOCK_SCALE),
                            Math.floor(blockAabb.max[1] * INV_BLOCK_SCALE),
                            Math.floor(blockAabb.max[2] * INV_BLOCK_SCALE)
                        ];
                        for (let x = minCell[0]; x <= maxCell[0]; x++) {
                            for (let y = minCell[1]; y <= maxCell[1]; y++) {
                                for (let z = minCell[2]; z <= maxCell[2]; z++) {
                                    const worldBlock = getBlockAtGrid([x, y, z]);
                                    if (!worldBlock) continue;
                                    const staticObb = getStaticBlockObb([x, y, z]);
                                    const hit = obbIntersection(obb, staticObb);
                                    if (!hit) continue;
                                    const points = collectContactPoints(obb, staticObb);
                                    const usePoints = points.length ? points : [[
                                        (obb.center[0] + staticObb.center[0]) * 0.5,
                                        (obb.center[1] + staticObb.center[1]) * 0.5,
                                        (obb.center[2] + staticObb.center[2]) * 0.5
                                    ]];
                                    const material = {
                                        restitution: getRestitution(worldBlock.id),
                                        staticFriction: getFriction(worldBlock.id),
                                        dynamicFriction: getFriction(worldBlock.id) * 0.8
                                    };
                                    usePoints.slice(0, 4).forEach(p => {
                                        addContact(obj, null, p, hit.normal, hit.penetration, material, false);
                                    });
                                }
                            }
                        }
                    });
                });

                const objList = Array.from(objectAabbs.keys());
                for (let i = 0; i < objList.length; i++) {
                    const objA = objList[i];
                    const aabbA = objectAabbs.get(objA);
                    for (let j = i + 1; j < objList.length; j++) {
                        const objB = objList[j];
                        const aabbB = objectAabbs.get(objB);
                        if (!aabbA || !aabbB) continue;
                        if (aabbA.min[0] >= aabbB.max[0] || aabbA.max[0] <= aabbB.min[0]) continue;
                        if (aabbA.min[1] >= aabbB.max[1] || aabbA.max[1] <= aabbB.min[1]) continue;
                        if (aabbA.min[2] >= aabbB.max[2] || aabbA.max[2] <= aabbB.min[2]) continue;
                        let added = 0;
                        for (let a = 0; a < objA.blocks.length; a++) {
                            const obbA = getBlockObb(objA, objA.blocks[a]);
                            for (let b = 0; b < objB.blocks.length; b++) {
                                if (added > 24) break;
                                const obbB = getBlockObb(objB, objB.blocks[b]);
                                const hit = obbIntersection(obbA, obbB);
                                if (!hit) continue;
                                const points = collectContactPoints(obbA, obbB);
                                const usePoints = points.length ? points : [[
                                    (obbA.center[0] + obbB.center[0]) * 0.5,
                                    (obbA.center[1] + obbB.center[1]) * 0.5,
                                    (obbA.center[2] + obbB.center[2]) * 0.5
                                ]];
                                usePoints.slice(0, 4).forEach(p => {
                                    addContact(objA, objB, p, hit.normal, hit.penetration, null, false);
                                    added += 1;
                                });
                            }
                        }
                    }
                }

                const applyImpulse = (body, impulse, r) => {
                    if (!body || body.invMass === 0) return;
                    body.velocity[0] -= impulse[0] * body.invMass;
                    body.velocity[1] -= impulse[1] * body.invMass;
                    body.velocity[2] -= impulse[2] * body.invMass;
                    const ang = mat3MultiplyVec(body.invInertiaWorld, cross(r, impulse));
                    body.angularVelocity[0] -= ang[0];
                    body.angularVelocity[1] -= ang[1];
                    body.angularVelocity[2] -= ang[2];
                };

                for (let iter = 0; iter < SOLVER_ITERATIONS; iter++) {
                    for (const contact of contacts) {
                        const a = contact.a;
                        const b = contact.b;
                        if (!a) continue;
                        const invMassA = a.invMass;
                        const invMassB = b ? b.invMass : 0;
                        if (invMassA + invMassB === 0) continue;
                        const ra = subtract(contact.point, a.comWorld);
                        const rb = b ? subtract(contact.point, b.comWorld) : [0, 0, 0];
                        const vA = add(a.velocity, cross(a.angularVelocity, ra));
                        const vB = b ? add(b.velocity, cross(b.angularVelocity, rb)) : [0, 0, 0];
                        const vRel = subtract(vB, vA);
                        const velAlongNormal = dot(vRel, contact.normal);
                        if (velAlongNormal > 0 && contact.penetration < CONTACT_SLOP) {
                            continue;
                        }
                        const raCrossN = cross(ra, contact.normal);
                        const rbCrossN = cross(rb, contact.normal);
                        const angA = mat3MultiplyVec(a.invInertiaWorld, raCrossN);
                        const angB = b ? mat3MultiplyVec(b.invInertiaWorld, rbCrossN) : [0, 0, 0];
                        const denom = invMassA + invMassB +
                            dot(contact.normal, cross(angA, ra)) +
                            dot(contact.normal, cross(angB, rb));
                        if (denom <= 0) continue;
                        let restitution = contact.restitution;
                        if (velAlongNormal > -RESTITUTION_VELOCITY_SLOP) restitution = 0;
                        const bias = Math.max(0, contact.penetration - CONTACT_SLOP) * (BAUMGARTE_BIAS / Math.max(delta, 1e-6));
                        let j = -(velAlongNormal * (1 + restitution) + bias) / denom;
                        if (j < 0) j = 0;
                        const impulse = scaleVec(contact.normal, j);
                        applyImpulse(a, impulse, ra);
                        if (b) {
                            b.velocity[0] += impulse[0] * b.invMass;
                            b.velocity[1] += impulse[1] * b.invMass;
                            b.velocity[2] += impulse[2] * b.invMass;
                            const ang = mat3MultiplyVec(b.invInertiaWorld, cross(rb, impulse));
                            b.angularVelocity[0] += ang[0];
                            b.angularVelocity[1] += ang[1];
                            b.angularVelocity[2] += ang[2];
                        }

                        const vA2 = add(a.velocity, cross(a.angularVelocity, ra));
                        const vB2 = b ? add(b.velocity, cross(b.angularVelocity, rb)) : [0, 0, 0];
                        const vRel2 = subtract(vB2, vA2);
                        const tangent = subtract(vRel2, scaleVec(contact.normal, dot(vRel2, contact.normal)));
                        const tLen = Math.hypot(tangent[0], tangent[1], tangent[2]);
                        if (tLen > 1e-6) {
                            const t = scaleVec(tangent, 1 / tLen);
                            const raCrossT = cross(ra, t);
                            const rbCrossT = cross(rb, t);
                            const angAT = mat3MultiplyVec(a.invInertiaWorld, raCrossT);
                            const angBT = b ? mat3MultiplyVec(b.invInertiaWorld, rbCrossT) : [0, 0, 0];
                            const denomT = invMassA + invMassB +
                                dot(t, cross(angAT, ra)) +
                                dot(t, cross(angBT, rb));
                            if (denomT > 0) {
                                let jt = -dot(vRel2, t) / denomT;
                                const maxStatic = contact.staticFriction * j;
                                let frictionImpulse = null;
                                if (Math.abs(jt) < maxStatic) {
                                    frictionImpulse = scaleVec(t, jt);
                                } else {
                                    const dir = jt < 0 ? -1 : 1;
                                    frictionImpulse = scaleVec(t, -dir * contact.dynamicFriction * j);
                                }
                                applyImpulse(a, frictionImpulse, ra);
                                if (b) {
                                    b.velocity[0] += frictionImpulse[0] * b.invMass;
                                    b.velocity[1] += frictionImpulse[1] * b.invMass;
                                    b.velocity[2] += frictionImpulse[2] * b.invMass;
                                    const angF = mat3MultiplyVec(b.invInertiaWorld, cross(rb, frictionImpulse));
                                    b.angularVelocity[0] += angF[0];
                                    b.angularVelocity[1] += angF[1];
                                    b.angularVelocity[2] += angF[2];
                                }
                            }
                        }
                    }
                }

                contacts.forEach(contact => {
                    const a = contact.a;
                    const b = contact.b;
                    const invMassA = a ? a.invMass : 0;
                    const invMassB = b ? b.invMass : 0;
                    const invMassSum = invMassA + invMassB;
                    if (invMassSum === 0) return;
                    const correctionMag = Math.max(contact.penetration - CONTACT_SLOP, 0) * 0.2;
                    if (correctionMag <= 0) return;
                    const correction = scaleVec(contact.normal, correctionMag / invMassSum);
                    if (a && invMassA > 0) {
                        a.origin = subtract(a.origin, scaleVec(correction, invMassA));
                    }
                    if (b && invMassB > 0) {
                        b.origin = add(b.origin, scaleVec(correction, invMassB));
                    }
                });

                worldObjects.forEach(obj => {
                    if (!obj.blocks.length) return;
                    obj.comWorld = getComWorld(obj);
                    const speed = Math.hypot(obj.velocity[0], obj.velocity[1], obj.velocity[2]);
                    const angSpeed = Math.hypot(obj.angularVelocity[0], obj.angularVelocity[1], obj.angularVelocity[2]);
                    let canSleep = speed < SLEEP_LINEAR_EPS && angSpeed < SLEEP_ANGULAR_EPS;
                    const groundPoints = groundContacts.get(obj) || [];
                    if (!groundPoints.length) {
                        canSleep = false;
                    }
                    if (groundPoints.length) {
                        const supportPoints = convexHull2D(groundPoints.map(p => [p[0], p[2]]));
                        const comProj = [obj.comWorld[0], obj.comWorld[2]];
                        const inside = pointInSupportPolygon(comProj, supportPoints);
                        if (!inside) {
                            canSleep = false;
                        }
                    }
                    if (canSleep) {
                        obj.sleepCounter = (obj.sleepCounter || 0) + 1;
                        if (obj.sleepCounter >= SLEEP_FRAMES) {
                            restWorldObject(obj);
                        }
                    } else {
                        obj.sleepCounter = 0;
                        if (obj.physicsState === PHYSICS_STATE.REST) {
                            wakeWorldObject(obj);
                        }
                    }
                });
            }

            function tryPlaceAt(gridPos, itemId, allowReplace) {
                const existing = getBlockAtGrid(gridPos);
                if (existing) {
                    if (!allowReplace || !REPLACEABLE_BLOCKS.has(existing.id)) {
                        return false;
                    }
                    removeBlock(existing);
                }
                addBlockAt(gridPos, itemId);
                return true;
            }

            function isDraggableItem(itemId) {
                return !!itemId && DRAGGABLE_ITEMS.has(itemId);
            }

            function getCurrentAxisMode() {
                return AXIS_MODES[axisModeIndex];
            }

            function cycleAxisMode(direction = 1) {
                const currentItem = hotbarSlots[selectedHotbar];
                if (isMultiBlockItem(currentItem)) {
                    const current = objectOrientationIndex.get(currentItem) || 0;
                    const next = (current + direction + ORIENTATIONS.length) % ORIENTATIONS.length;
                    objectOrientationIndex.set(currentItem, next);
                    updateHoverPreviews();
                    return;
                }
                axisModeIndex = (axisModeIndex + direction + AXIS_MODES.length) % AXIS_MODES.length;
                if (dragState) {
                    dragState.axis = getCurrentAxisMode();
                    dragState.lastTarget = dragState.anchor ? dragState.anchor.slice() : dragState.lastTarget;
                }
                updateDragPreviewFromHighlight();
            }

            function getAxisModeFromNormal(normal) {
                if (!normal) return null;
                const ax = Math.abs(normal[0]);
                const ay = Math.abs(normal[1]);
                const az = Math.abs(normal[2]);
                if (ay >= ax && ay >= az) {
                    return AXIS_MODES[0];
                }
                if (ax >= az) {
                    return AXIS_MODES[2];
                }
                return AXIS_MODES[1];
            }

            function clampDragDelta(value) {
                if (value > MAX_DRAG_EXTENT) return MAX_DRAG_EXTENT;
                if (value < -MAX_DRAG_EXTENT) return -MAX_DRAG_EXTENT;
                return value;
            }

            function getPlacementTargetFromHighlight(info, crouchingOverride) {
                if (!info) return null;
                if (info.type === 'ground') {
                    return info.position.slice();
                }
                if (info.type === 'block' && info.block) {
                    const crouchingState = typeof crouchingOverride === 'boolean' ? crouchingOverride : crouchState;
                    if (!crouchingState && REPLACEABLE_BLOCKS.has(info.block.id)) {
                        return info.block.grid.slice();
                    }
                    if (!info.normal) return null;
                    return [
                        info.block.grid[0] + info.normal[0],
                        info.block.grid[1] + info.normal[1],
                        info.block.grid[2] + info.normal[2]
                    ];
                }
                return null;
            }

            function getDragTargetOnPlane() {
                if (!dragState) return null;
                const axis = dragState.axis || getCurrentAxisMode();
                let originGrid = worldToGrid(camera.position);
                let dirGrid;
                if (dragState.layer === 'object' && dragState.obj) {
                    originGrid = worldToObjectLocal(dragState.obj, camera.position);
                    const localDir = rotateVecByQuatInv(lookDirection, dragState.obj.rotation);
                    dirGrid = normalizeVec(localDir);
                } else {
                    dirGrid = normalizeVec(lookDirection);
                }
                const denom = dirGrid[axis.locked];
                if (Math.abs(denom) < 1e-6) return null;
                const t = (dragState.anchor[axis.locked] - originGrid[axis.locked]) / denom;
                const hit = [
                    originGrid[0] + dirGrid[0] * t,
                    originGrid[1] + dirGrid[1] * t,
                    originGrid[2] + dirGrid[2] * t
                ];
                const snapped = snapGrid(hit);
                snapped[axis.locked] = dragState.anchor[axis.locked];
                return snapped;
            }

            function getBreakTargetFromHighlight(info) {
                if (!info || info.type !== 'block' || !info.block) return null;
                return info.block.grid.slice();
            }

            function projectTargetToAxis(anchor, target, axis) {
                const projected = anchor.slice();
                const axes = axis.axes;
                axes.forEach(idx => {
                    const delta = target ? target[idx] - anchor[idx] : 0;
                    projected[idx] = anchor[idx] + clampDragDelta(delta);
                });
                projected[axis.locked] = anchor[axis.locked];
                return projected;
            }

            function isDragBlockingBlock(blockId, crouching) {
                if (!blockId) return false;
                if (!crouching && REPLACEABLE_BLOCKS.has(blockId)) return false;
                return true;
            }

            function isDragBlockingCell(cell, crouching) {
                const block = getBlockAtGrid(cell);
                if (!block) return false;
                return isDragBlockingBlock(block.id, crouching);
            }

            function getFallbackDragTarget() {
                const distance = 4 * BLOCK_SCALE;
                const fallbackWorld = [
                    camera.position[0] + lookDirection[0] * distance,
                    camera.position[1] + lookDirection[1] * distance,
                    camera.position[2] + lookDirection[2] * distance
                ];
                return snapGrid(worldToGrid(fallbackWorld));
            }

            function clampDragCornerToObstacles(anchor, corner, axis, crouching) {
                const axes = axis.axes;
                const a = axes[0];
                const b = axes[1];
                const anchorA = anchor[a];
                const anchorB = anchor[b];
                let targetA = corner[a];
                let targetB = corner[b];
                const stepA = targetA >= anchorA ? 1 : -1;
                const stepB = targetB >= anchorB ? 1 : -1;
                let minB = Math.min(anchorB, targetB);
                let maxB = Math.max(anchorB, targetB);

                if (targetA !== anchorA) {
                    if (stepA > 0) {
                        for (let aVal = anchorA + 1; aVal <= targetA; aVal++) {
                            for (let bVal = minB; bVal <= maxB; bVal++) {
                                const cell = anchor.slice();
                                cell[a] = aVal;
                                cell[b] = bVal;
                                if (isDragBlockingCell(cell, crouching)) {
                                    targetA = aVal - 1;
                                    aVal = targetA + 1;
                                    break;
                                }
                            }
                        }
                    } else {
                        for (let aVal = anchorA - 1; aVal >= targetA; aVal--) {
                            for (let bVal = minB; bVal <= maxB; bVal++) {
                                const cell = anchor.slice();
                                cell[a] = aVal;
                                cell[b] = bVal;
                                if (isDragBlockingCell(cell, crouching)) {
                                    targetA = aVal + 1;
                                    aVal = targetA - 1;
                                    break;
                                }
                            }
                        }
                    }
                }

                let minA = Math.min(anchorA, targetA);
                let maxA = Math.max(anchorA, targetA);
                if (targetB !== anchorB) {
                    if (stepB > 0) {
                        for (let bVal = anchorB + 1; bVal <= targetB; bVal++) {
                            for (let aVal = minA; aVal <= maxA; aVal++) {
                                const cell = anchor.slice();
                                cell[a] = aVal;
                                cell[b] = bVal;
                                if (isDragBlockingCell(cell, crouching)) {
                                    targetB = bVal - 1;
                                    bVal = targetB + 1;
                                    break;
                                }
                            }
                        }
                    } else {
                        for (let bVal = anchorB - 1; bVal >= targetB; bVal--) {
                            for (let aVal = minA; aVal <= maxA; aVal++) {
                                const cell = anchor.slice();
                                cell[a] = aVal;
                                cell[b] = bVal;
                                if (isDragBlockingCell(cell, crouching)) {
                                    targetB = bVal + 1;
                                    bVal = targetB - 1;
                                    break;
                                }
                            }
                        }
                    }
                }

                const clamped = corner.slice();
                clamped[a] = targetA;
                clamped[b] = targetB;
                clamped[axis.locked] = anchor[axis.locked];
                return clamped;
            }

            function buildAxisRectangleCells(anchor, corner, axis) {
                const cells = [];
                const axes = axis.axes;
                const spanA = {
                    idx: axes[0],
                    min: Math.min(anchor[axes[0]], corner[axes[0]]),
                    max: Math.max(anchor[axes[0]], corner[axes[0]])
                };
                const spanB = {
                    idx: axes[1],
                    min: Math.min(anchor[axes[1]], corner[axes[1]]),
                    max: Math.max(anchor[axes[1]], corner[axes[1]])
                };
                for (let a = spanA.min; a <= spanA.max; a++) {
                    for (let b = spanB.min; b <= spanB.max; b++) {
                        const cell = anchor.slice();
                        cell[spanA.idx] = a;
                        cell[spanB.idx] = b;
                        cells.push(cell);
                    }
                }
                return cells;
            }

            function updateDragPreviewFromHighlight() {
                if (!dragState) return;
                const axis = dragState.axis || getCurrentAxisMode();
                const target = getDragTargetOnPlane();
                if (target) {
                    dragState.lastTarget = target.slice();
                }
                let projected = projectTargetToAxis(
                    dragState.anchor,
                    dragState.lastTarget || dragState.anchor,
                    axis
                );
                if (dragState.mode === 'place') {
                    if (!dragState.layer || dragState.layer === 'world') {
                        projected = clampDragCornerToObstacles(dragState.anchor, projected, axis, crouchState);
                    }
                }
                dragState.corner = projected;
                const allCells = buildAxisRectangleCells(dragState.anchor, projected, axis);
                let cells = allCells;
                if (dragState.mode === 'break') {
                    dragState.previewCells = allCells;
                    if (dragState.layer === 'object' && dragState.obj) {
                        cells = allCells.filter(cell => {
                            const hit = getObjectBlockAtLocal(dragState.obj, cell);
                            return !!(hit && DRAGGABLE_ITEMS.has(hit.block.id));
                        });
                    } else {
                        cells = allCells.filter(cell => {
                            const block = getBlockAtGrid(cell);
                            return !!(block && DRAGGABLE_ITEMS.has(block.id));
                        });
                    }
                }
                dragState.cells = cells;
                if (dragState.mode === 'place') {
                    placementPreviewCells = dragState.cells.slice();
                    if (dragState.layer === 'object' && dragState.obj) {
                        placementPreviewWorldCells = dragState.cells.map(c => ({
                            position: localCellToWorld(dragState.obj, c),
                            rotation: dragState.obj.rotation
                        }));
                    }
                } else {
                    removalPreviewCells = (dragState.previewCells || dragState.cells).slice();
                    if (dragState.layer === 'object' && dragState.obj) {
                        removalPreviewWorldCells = (dragState.previewCells || dragState.cells).map(c => ({
                            position: localCellToWorld(dragState.obj, c),
                            rotation: dragState.obj.rotation
                        }));
                    }
                }
            }

            function beginDrag(mode) {
                if (dragState) return true;
                if (mode === 'place') {
                    const itemId = hotbarSlots[selectedHotbar];
                    if (!itemId || !isDraggableItem(itemId)) return false;
                    const anchor = getPlacementTargetFromHighlight(highlightInfo, crouchState);
                    if (!anchor) return false;
                    dragState = {
                        mode: 'place',
                        anchor: anchor.slice(),
                        axis: getCurrentAxisMode(),
                        itemId,
                        button: 0,
                        cells: [],
                        lastTarget: anchor.slice(),
                        layer: highlightInfo && highlightInfo.layer ? highlightInfo.layer : 'world',
                        obj: highlightInfo && highlightInfo.obj ? highlightInfo.obj : null
                    };
                } else if (mode === 'break') {
                    if (!highlightInfo || highlightInfo.type !== 'block' || !highlightInfo.block || !DRAGGABLE_ITEMS.has(highlightInfo.block.id)) {
                        return false;
                    }
                    const anchor = getBreakTargetFromHighlight(highlightInfo);
                    if (!anchor) return false;
                    const axisFromNormal = getAxisModeFromNormal(highlightInfo.normal);
                    dragState = {
                        mode: 'break',
                        anchor: anchor.slice(),
                        axis: axisFromNormal || getCurrentAxisMode(),
                        button: 2,
                        cells: [],
                        lastTarget: anchor.slice(),
                        layer: highlightInfo && highlightInfo.layer ? highlightInfo.layer : 'world',
                        obj: highlightInfo && highlightInfo.obj ? highlightInfo.obj : null
                    };
                } else {
                    return false;
                }
                updateDragPreviewFromHighlight();
                return true;
            }

            function cancelPlacementHold() {
                placementHoldState = null;
            }

            function completePlacementHold() {
                if (!placementHoldState || dragState) return;
                const hold = placementHoldState;
                placementHoldState = null;
                if (!hold.itemId || isDraggableItem(hold.itemId)) return;
                if (!hold.targetGrid) return;
                const allowReplace = !crouchState && hold.allowReplace;
                if (isMultiBlockItem(hold.itemId)) {
                    placeMultiBlockAt(hold.targetGrid, hold.itemId, hold.normal);
                } else {
                    tryPlaceAt(hold.targetGrid, hold.itemId, allowReplace);
                }
            }

            function setBreakProgressVisible(visible) {
                if (!breakProgress) return;
                breakProgress.classList.toggle('visible', visible);
            }

            function updateBreakProgressVisual(progress) {
                if (!breakProgress) return;
                const degrees = Math.min(360, Math.max(0, progress * 360));
                breakProgress.style.background = `conic-gradient(rgba(255, 196, 120, 0.9) ${degrees}deg, rgba(255, 196, 120, 0.1) ${degrees}deg)`;
            }

            function startBreakHold(info) {
                if (!info || !info.block) return;
                const obj = info.layer === 'object' ? info.obj : null;
                breakHoldState = {
                    grid: info.block.grid.slice(),
                    blockKey: info.block.key,
                    layer: info.layer || 'world',
                    obj,
                    blockIndex: typeof info.blockIndex === 'number' ? info.blockIndex : null,
                    startedAt: performance.now(),
                    duration: BREAK_HOLD_DURATION,
                    ready: false
                };
                setBreakProgressVisible(true);
                updateBreakProgressVisual(0);
            }

            function cancelBreakHold() {
                if (!breakHoldState) return;
                breakHoldState = null;
                setBreakProgressVisible(false);
            }

            function completeBreakHold() {
                if (!breakHoldState) return;
                const wasReady = breakHoldState.ready;
                const targetGrid = breakHoldState.grid.slice();
                const blockKey = breakHoldState.blockKey;
                const layer = breakHoldState.layer;
                const obj = breakHoldState.obj;
                const storedIndex = breakHoldState.blockIndex;
                cancelBreakHold();
                if (!wasReady) return;
                if (layer === 'object' && obj) {
                    const idx = typeof storedIndex === 'number'
                        ? storedIndex
                        : obj.blocks.findIndex(b =>
                            Math.round(b.offset[0]) === targetGrid[0] &&
                            Math.round(b.offset[1]) === targetGrid[1] &&
                            Math.round(b.offset[2]) === targetGrid[2]
                        );
                    if (idx !== -1) {
                        removeObjectBlockAt(obj, idx);
                    }
                } else {
                    const block = getBlockAtGrid(targetGrid);
                    if (block && block.key === blockKey) {
                        removeBlock(block);
                    }
                }
            }

            function updateBreakHold(time) {
                if (!breakHoldState) return;
                if (!pointerButtons.right) {
                    cancelBreakHold();
                    return;
                }
                if (!highlightInfo || highlightInfo.type !== 'block' || !highlightInfo.block || highlightInfo.block.key !== breakHoldState.blockKey) {
                    cancelBreakHold();
                    return;
                }
                if (breakHoldState.layer === 'object') {
                    const obj = breakHoldState.obj;
                    if (!obj || !obj.blocks || !obj.blocks.length) {
                        cancelBreakHold();
                        return;
                    }
                    const idx = typeof breakHoldState.blockIndex === 'number'
                        ? breakHoldState.blockIndex
                        : obj.blocks.findIndex(b =>
                            Math.round(b.offset[0]) === breakHoldState.grid[0] &&
                            Math.round(b.offset[1]) === breakHoldState.grid[1] &&
                            Math.round(b.offset[2]) === breakHoldState.grid[2]
                        );
                    if (idx === -1) {
                        cancelBreakHold();
                        return;
                    }
                } else {
                    const block = getBlockAtGrid(breakHoldState.grid);
                    if (!block || block.key !== breakHoldState.blockKey) {
                        cancelBreakHold();
                        return;
                    }
                }
                const elapsed = time - breakHoldState.startedAt;
                const progress = Math.min(1, elapsed / breakHoldState.duration);
                breakHoldState.ready = progress >= 1;
                updateBreakProgressVisual(progress);
                if (breakHoldState.ready) {
                    const targetGrid = breakHoldState.grid.slice();
                    const blockKey = breakHoldState.blockKey;
                    const layer = breakHoldState.layer;
                    const obj = breakHoldState.obj;
                    const storedIndex = breakHoldState.blockIndex;
                    cancelBreakHold();
                    if (layer === 'object' && obj) {
                        const idx = typeof storedIndex === 'number'
                            ? storedIndex
                            : obj.blocks.findIndex(b =>
                                Math.round(b.offset[0]) === targetGrid[0] &&
                                Math.round(b.offset[1]) === targetGrid[1] &&
                                Math.round(b.offset[2]) === targetGrid[2]
                            );
                        if (idx !== -1) {
                            removeObjectBlockAt(obj, idx);
                        }
                    } else {
                        const finishedBlock = getBlockAtGrid(targetGrid);
                        if (finishedBlock && finishedBlock.key === blockKey) {
                            removeBlock(finishedBlock);
                        }
                    }
                }
            }

            function handleOppositeButtonDuringDrag(button) {
                if (!dragState || dragState.button === button) return false;
                resetDragState(false);
                dragCancelLock = true;
                cancelPlacementHold();
                cancelBreakHold();
                return true;
            }

            function handleOppositeButtonDuringHold(button) {
                if (dragCancelLock) return true;
                if (button === 0) {
                    if (breakHoldState) {
                        dragCancelLock = true;
                        cancelPlacementHold();
                        cancelBreakHold();
                        return true;
                    }
                } else if (button === 2) {
                    if (placementHoldState) {
                        dragCancelLock = true;
                        cancelPlacementHold();
                        cancelBreakHold();
                        return true;
                    }
                }
                return false;
            }

            function handleLeftDown() {
                pointerButtons.left = true;
                if (handleOppositeButtonDuringDrag(0)) {
                    return;
                }
                if (handleOppositeButtonDuringHold(0)) return;
                if (dragCancelLock) return;
                const itemId = hotbarSlots[selectedHotbar];
                if (!itemId) return;
                if (highlightInfo && highlightInfo.layer === 'object' && highlightInfo.obj) {
                    if (isDraggableItem(itemId)) {
                        if (!beginDrag('place')) {
                            return;
                        }
                    } else {
                        placeBlock();
                    }
                    return;
                }
                if (isDraggableItem(itemId)) {
                    if (!beginDrag('place')) {
                        placeBlock();
                    }
                    return;
                }
                const targetGrid = getPlacementTargetFromHighlight(highlightInfo, crouchState);
                if (!targetGrid) return;
                const allowReplace = highlightInfo && highlightInfo.type === 'block' && highlightInfo.block && REPLACEABLE_BLOCKS.has(highlightInfo.block.id);
                placementHoldState = {
                    startedAt: performance.now(),
                    targetGrid: targetGrid.slice(),
                    itemId,
                    allowReplace: !!allowReplace,
                    normal: highlightInfo && highlightInfo.normal ? highlightInfo.normal.slice() : null
                };
            }

            function handleRightDown() {
                pointerButtons.right = true;
                if (handleOppositeButtonDuringDrag(2)) {
                    return;
                }
                if (handleOppositeButtonDuringHold(2)) return;
                if (dragCancelLock) return;
                if (beginDrag('break')) return;
                if (!highlightInfo || highlightInfo.type !== 'block' || !highlightInfo.block) {
                    return;
                }
                if (DRAGGABLE_ITEMS.has(highlightInfo.block.id)) {
                    breakBlock();
                    return;
                }
                startBreakHold(highlightInfo);
            }

            function handleLeftUp() {
                pointerButtons.left = false;
                if (dragState && dragState.button === 0) {
                    resetDragState(true);
                }
                if (placementHoldState) {
                    completePlacementHold();
                }
                if (!pointerButtons.left && !pointerButtons.right) {
                    dragCancelLock = false;
                }
            }

            function handleRightUp() {
                pointerButtons.right = false;
                if (dragState && dragState.button === 2) {
                    resetDragState(true);
                }
                if (breakHoldState) {
                    completeBreakHold();
                }
                if (!pointerButtons.left && !pointerButtons.right) {
                    dragCancelLock = false;
                }
            }

            function resetPointerState() {
                pointerButtons.left = false;
                pointerButtons.right = false;
                dragCancelLock = false;
            }

            function resetDragState(applyChanges) {
                if (!dragState) return;
                if (applyChanges && dragState.cells && dragState.cells.length) {
                    if (dragState.mode === 'place' && dragState.itemId) {
                        const allowReplace = !crouchState;
                        if (dragState.layer === 'object' && dragState.obj) {
                            dragState.cells.forEach(cell => {
                                placeObjectBlock({ obj: dragState.obj, position: cell }, dragState.itemId);
                            });
                        } else {
                            dragState.cells.forEach(cell => {
                                tryPlaceAt(cell, dragState.itemId, allowReplace);
                            });
                        }
                    } else if (dragState.mode === 'break') {
                        if (dragState.layer === 'object' && dragState.obj) {
                            const toRemove = new Set();
                            dragState.cells.forEach(cell => {
                                const hit = getObjectBlockAtLocal(dragState.obj, cell);
                                if (hit && DRAGGABLE_ITEMS.has(hit.block.id)) {
                                    toRemove.add(hit.index);
                                }
                            });
                            if (toRemove.size) {
                                const indices = Array.from(toRemove).sort((a, b) => b - a);
                                indices.forEach(idx => {
                                    if (idx >= 0 && idx < dragState.obj.blocks.length) {
                                        dragState.obj.blocks.splice(idx, 1);
                                    }
                                });
                                if (!dragState.obj.blocks.length) {
                                    const remIdx = worldObjects.indexOf(dragState.obj);
                                    if (remIdx !== -1) worldObjects.splice(remIdx, 1);
                                } else if (!splitWorldObjectIfDisconnected(dragState.obj)) {
                                    refreshObjectProperties(dragState.obj);
                                    wakeWorldObject(dragState.obj);
                                }
                            }
                        } else {
                            dragState.cells.forEach(cell => {
                                const block = getBlockAtGrid(cell);
                                if (block && DRAGGABLE_ITEMS.has(block.id)) {
                                    removeBlock(block);
                                }
                            });
                        }
                    }
                }
                dragState = null;
                placementPreviewCells = [];
                removalPreviewCells = [];
                updateHoverPreviews();
            }

            function updateHoverPreviews() {
                placementPreviewCells = dragState && dragState.mode === 'place' ? placementPreviewCells : [];
                removalPreviewCells = dragState && dragState.mode === 'break' ? removalPreviewCells : [];
                const itemId = hotbarSlots[selectedHotbar];
                hoverPlacementCell = null;
                hoverRemovalCell = null;
                hoverPreviewCells = [];
                hoverPreviewWorldCells = [];
                placementPreviewWorldCells = [];
                removalPreviewWorldCells = [];
                placementPreviewNormal = null;
                let placeTarget = null;
                if (placementHoldState && placementHoldState.itemId && isMultiBlockItem(placementHoldState.itemId) && pointerButtons.left) {
                    const retarget = getPlacementTargetFromHighlight(highlightInfo, crouchState);
                    if (retarget) {
                        placementHoldState.targetGrid = retarget.slice();
                        placementHoldState.normal = highlightInfo && highlightInfo.normal ? highlightInfo.normal.slice() : placementHoldState.normal;
                    }
                }
                if (itemId && highlightInfo) {
                    if (highlightInfo.layer === 'object' && highlightInfo.block) {
                        if (highlightInfo.normal) {
                            placeTarget = [
                                highlightInfo.block.grid[0] + highlightInfo.normal[0],
                                highlightInfo.block.grid[1] + highlightInfo.normal[1],
                                highlightInfo.block.grid[2] + highlightInfo.normal[2]
                            ];
                        } else {
                            placeTarget = highlightInfo.block.grid.slice();
                        }
                        hoverPlacementCell = placeTarget.slice();
                        placementPreviewNormal = highlightInfo.normal ? highlightInfo.normal.slice() : null;
                        hoverPreviewWorldCells = hoverPlacementCell.map ? [{
                            position: localCellToWorld(highlightInfo.obj, hoverPlacementCell),
                            rotation: highlightInfo.obj.rotation
                        }] : [];
                    } else {
                        placeTarget = getPlacementTargetFromHighlight(highlightInfo, crouchState);
                        if (placeTarget) {
                            hoverPlacementCell = placeTarget.slice();
                            placementPreviewNormal = highlightInfo.normal ? highlightInfo.normal.slice() : null;
                        }
                    }
                }
                if (itemId && isMultiBlockItem(itemId) && hoverPlacementCell) {
                    const cells = getMultiBlockCells(hoverPlacementCell, itemId, placementPreviewNormal);
                    hoverPreviewCells = cells;
                    if (highlightInfo && highlightInfo.layer === 'object' && highlightInfo.obj) {
                        hoverPreviewWorldCells = cells.map(c => ({
                            position: localCellToWorld(highlightInfo.obj, c),
                            rotation: highlightInfo.obj.rotation
                        }));
                    }
                } else if (highlightInfo) {
                    if (highlightInfo.type === 'block' && highlightInfo.block) {
                        hoverPreviewCells = [highlightInfo.block.grid.slice()];
                        if (highlightInfo.layer === 'object' && highlightInfo.obj) {
                            hoverPreviewWorldCells = hoverPreviewCells.map(c => ({
                                position: localCellToWorld(highlightInfo.obj, c),
                                rotation: highlightInfo.obj.rotation
                            }));
                        }
                    } else if (highlightInfo.type === 'ground') {
                        hoverPreviewCells = [highlightInfo.position.slice()];
                        hoverPreviewWorldCells = [];
                    }
                    if (placeTarget) {
                        hoverPreviewCells = [placeTarget.slice()];
                        if (highlightInfo.layer === 'object' && highlightInfo.obj) {
                            hoverPreviewWorldCells = hoverPreviewCells.map(c => ({
                                position: localCellToWorld(highlightInfo.obj, c),
                                rotation: highlightInfo.obj.rotation
                            }));
                        }
                    }
                }
                const showRemovalPreview = pointerButtons.right || breakHoldState || (dragState && dragState.mode === 'break');
                if (showRemovalPreview && highlightInfo && highlightInfo.type === 'block' && highlightInfo.block && DRAGGABLE_ITEMS.has(highlightInfo.block.id)) {
                    const removalTarget = getBreakTargetFromHighlight(highlightInfo);
                    if (removalTarget) {
                        hoverRemovalCell = removalTarget.slice();
                        if (highlightInfo.layer === 'object' && highlightInfo.obj) {
                            removalPreviewWorldCells = [{
                                position: localCellToWorld(highlightInfo.obj, removalTarget),
                                rotation: highlightInfo.obj.rotation
                            }];
                        } else {
                            removalPreviewWorldCells = [];
                        }
                    } else {
                        removalPreviewWorldCells = [];
                    }
                }
                if (placementHoldState && placementHoldState.itemId) {
                    if (isMultiBlockItem(placementHoldState.itemId)) {
                        placementPreviewCells = getMultiBlockCells(placementHoldState.targetGrid, placementHoldState.itemId, placementHoldState.normal);
                    } else {
                        placementPreviewCells = [placementHoldState.targetGrid.slice()];
                    }
                    if (highlightInfo && highlightInfo.layer === 'object' && highlightInfo.obj) {
                        placementPreviewWorldCells = placementPreviewCells.map(c => ({
                            position: localCellToWorld(highlightInfo.obj, c),
                            rotation: highlightInfo.obj.rotation
                        }));
                    } else {
                        placementPreviewWorldCells = [];
                    }
                } else {
                    placementPreviewWorldCells = [];
                }
                if (breakHoldState && breakHoldState.grid) {
                    removalPreviewCells = [breakHoldState.grid.slice()];
                    if (highlightInfo && highlightInfo.layer === 'object' && highlightInfo.obj) {
                        removalPreviewWorldCells = [{
                            position: localCellToWorld(highlightInfo.obj, breakHoldState.grid),
                            rotation: highlightInfo.obj.rotation
                        }];
                    } else {
                        removalPreviewWorldCells = [];
                    }
                }
                if (dragState && dragState.layer === 'object' && dragState.obj) {
                    if (dragState.mode === 'place') {
                        placementPreviewWorldCells = dragState.cells.map(c => ({
                            position: localCellToWorld(dragState.obj, c),
                            rotation: dragState.obj.rotation
                        }));
                        removalPreviewWorldCells = [];
                    } else if (dragState.mode === 'break') {
                        removalPreviewWorldCells = dragState.cells.map(c => ({
                            position: localCellToWorld(dragState.obj, c),
                            rotation: dragState.obj.rotation
                        }));
                        placementPreviewWorldCells = [];
                    }
                }
            }

            function drawPreviewCells(cells, style) {
                if (!cells || !cells.length) return;
                const previewSet = new Set(cells.map(cell => gridKey(cell[0], cell[1], cell[2])));
                const depthEnabled = gl.isEnabled(gl.DEPTH_TEST);
                if (!depthEnabled) {
                    gl.enable(gl.DEPTH_TEST);
                }
                gl.enable(gl.BLEND);
                bindCube();
                gl.uniform1i(checkerLocation, 0);
                gl.uniform1i(useTextureLocation, 0);
                gl.uniform1i(useNormalLocation, 0);
                gl.uniform1i(useAsgLocation, 0);
                gl.uniform1i(useLightingLocation, 0);
                gl.uniform1f(tileLocation, BLOCK_SCALE);
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, fallbackTexture);
                const prevDepthFunc = gl.getParameter(gl.DEPTH_FUNC);
                // Depth pre-pass: write depth only so faces occlude each other.
                gl.colorMask(false, false, false, false);
                gl.depthMask(true);
                gl.depthFunc(gl.LESS);
                cells.forEach(cell => {
                    const center = gridToWorld(cell);
                    gl.uniformMatrix4fv(modelLocation, false, createTranslationMatrix(center));
                    for (let face = 0; face < cubeFaceDirections.length; face++) {
                        const dir = cubeFaceDirections[face];
                        const neighbor = [
                            cell[0] + dir[0],
                            cell[1] + dir[1],
                            cell[2] + dir[2]
                        ];
                        if (previewSet.has(gridKey(neighbor[0], neighbor[1], neighbor[2]))) {
                            continue;
                        }
                        gl.drawArrays(gl.TRIANGLES, cubeFaceOffsets[face], 6);
                    }
                });
                // Color pass: depth test only, keep world visible.
                gl.colorMask(true, true, true, true);
                gl.depthMask(false);
                gl.depthFunc(gl.LEQUAL);
                gl.uniform1f(alphaLocation, PREVIEW_FILL_ALPHA);
                gl.uniform3fv(colorLocation, style.fill);
                cells.forEach(cell => {
                    const center = gridToWorld(cell);
                    gl.uniformMatrix4fv(modelLocation, false, createTranslationMatrix(center));
                    for (let face = 0; face < cubeFaceDirections.length; face++) {
                        const dir = cubeFaceDirections[face];
                        const neighbor = [
                            cell[0] + dir[0],
                            cell[1] + dir[1],
                            cell[2] + dir[2]
                        ];
                        if (previewSet.has(gridKey(neighbor[0], neighbor[1], neighbor[2]))) {
                            continue;
                        }
                        gl.drawArrays(gl.TRIANGLES, cubeFaceOffsets[face], 6);
                    }
                });
                gl.uniform1f(alphaLocation, PREVIEW_OUTLINE_ALPHA);
                gl.uniform3fv(colorLocation, style.outline);
                cells.forEach(cell => {
                    const center = gridToWorld(cell);
                    gl.uniformMatrix4fv(modelLocation, false, createTranslationMatrix(center));
                    for (let face = 0; face < cubeFaceDirections.length; face++) {
                        const dir = cubeFaceDirections[face];
                        const neighbor = [
                            cell[0] + dir[0],
                            cell[1] + dir[1],
                            cell[2] + dir[2]
                        ];
                        if (previewSet.has(gridKey(neighbor[0], neighbor[1], neighbor[2]))) {
                            continue;
                        }
                        bindEdgeBuffer(cubeFaceEdgeBuffers[face]);
                        gl.drawArrays(gl.LINES, 0, cubeFaceEdgeVertexCounts[face]);
                    }
                });
                gl.uniform1f(alphaLocation, 1);
                gl.depthMask(true);
                gl.depthFunc(prevDepthFunc);
                if (!depthEnabled) {
                    gl.disable(gl.DEPTH_TEST);
                }
            }

            function drawCanisterMeshInstance(block, def, material, groupInfo) {
                const mesh = getCanisterMesh(block.id);
                if (!mesh) return false;
                const albedo = material ? material.albedo : null;
                const normal = material ? material.normal : null;
                const asg = material ? material.asg : null;
                gl.uniform1i(useTextureLocation, albedo ? 1 : 0);
                gl.uniform1f(tileLocation, 1);
                gl.uniform1i(useNormalLocation, normal ? 1 : 0);
                gl.uniform1i(useAsgLocation, asg ? 1 : 0);
                gl.uniform1i(useLightingLocation, 1);
                gl.uniform1i(useMeshUvLocation, 1);
                gl.uniform3fv(colorLocation, block.color);
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, albedo || fallbackTexture);
                gl.activeTexture(gl.TEXTURE1);
                gl.bindTexture(gl.TEXTURE_2D, normal || neutralNormalTexture);
                gl.activeTexture(gl.TEXTURE2);
                gl.bindTexture(gl.TEXTURE_2D, asg || neutralAsgTexture);
                const orient = ORIENTATIONS[groupInfo.orientationIndex || 0] || AXIS_MODES[1];
                const cells = groupInfo.cells && groupInfo.cells.length ? groupInfo.cells : [block.grid];
                const min = [Infinity, Infinity, Infinity];
                cells.forEach(c => {
                    min[0] = Math.min(min[0], c[0]);
                    min[1] = Math.min(min[1], c[1]);
                    min[2] = Math.min(min[2], c[2]);
                });
                const anchor = min[0] === Infinity ? (groupInfo.anchor || block.grid) : min;
                const model = createBasisMatrix(
                    orient.forward,
                    orient.up,
                    1,
                    [
                        anchor[0] * BLOCK_SCALE,
                        anchor[1] * BLOCK_SCALE,
                        anchor[2] * BLOCK_SCALE
                    ]
                );
                gl.uniformMatrix4fv(modelLocation, false, model);
                bindMeshBuffers(mesh);
                gl.drawElements(gl.TRIANGLES, mesh.indexCount, mesh.indexType, 0);
                return true;
            }

            function getArrowMode() {
                if (dragCancelLock) return null;
                if (dragState) return dragState.mode === 'break' ? null : dragState.mode;
                if (breakHoldState) return null;
                if (placementHoldState) return 'place';
                if (pointerButtons.left) {
                    const itemId = hotbarSlots[selectedHotbar];
                    if (itemId && isDraggableItem(itemId)) return 'place';
                    return null;
                }
                const itemId = hotbarSlots[selectedHotbar];
                if (itemId && isDraggableItem(itemId) && hoverPlacementCell) {
                    return 'hover';
                }
                return null;
            }

            function getArrowCell() {
                if (dragState) {
                    if (dragState.corner) return dragState.corner.slice();
                    if (dragState.anchor) return dragState.anchor.slice();
                }
                if (hoverPlacementCell) return hoverPlacementCell.slice();
                if (hoverRemovalCell) return hoverRemovalCell.slice();
                if (highlightInfo) {
                    if (highlightInfo.type === 'block' && highlightInfo.block) {
                        return highlightInfo.block.grid.slice();
                    }
                    if (highlightInfo.type === 'ground') {
                        return highlightInfo.position.slice();
                    }
                }
                return null;
            }

            function drawAxisArrow() {
                const mode = getArrowMode();
                if (!mode) return;
                const axis = dragState ? (dragState.axis || getCurrentAxisMode()) : getCurrentAxisMode();
                let gridPos = null;
                if (dragState && dragState.anchor) {
                    const corner = dragState.corner || dragState.anchor;
                    const a = axis.axes[0];
                    const b = axis.axes[1];
                    const center = dragState.anchor.slice();
                    center[a] = (Math.min(dragState.anchor[a], corner[a]) + Math.max(dragState.anchor[a], corner[a])) / 2;
                    center[b] = (Math.min(dragState.anchor[b], corner[b]) + Math.max(dragState.anchor[b], corner[b])) / 2;
                    center[axis.locked] = dragState.anchor[axis.locked];
                    gridPos = center;
                } else {
                    const cell = getArrowCell();
                    if (!cell) return;
                    gridPos = cell;
                }
                let position;
                if (highlightInfo && highlightInfo.layer === 'object' && highlightInfo.obj) {
                    position = localCellToWorld(highlightInfo.obj, gridPos);
                } else {
                    position = gridToWorld(gridPos);
                }
                const scale = BLOCK_SCALE * 0.95;
                const style = PREVIEW_STYLES[mode];
                const depthEnabled = gl.isEnabled(gl.DEPTH_TEST);
                if (depthEnabled) {
                    gl.disable(gl.DEPTH_TEST);
                }
                bindBufferAttributes(arrowBuffer, 5, false);
                gl.uniform1i(checkerLocation, 0);
                gl.uniform1i(useTextureLocation, 0);
                gl.uniform1i(useNormalLocation, 0);
                gl.uniform1i(useAsgLocation, 0);
                gl.uniform1i(useLightingLocation, 0);
                gl.uniform1i(useMeshUvLocation, 0);
                gl.uniform1f(tileLocation, 1);
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, fallbackTexture);
                gl.uniform1f(alphaLocation, 1);
                gl.uniform3fv(colorLocation, style.fill);
                let arrowForward = axis.forward;
                let arrowUp = axis.up;
                if (highlightInfo && highlightInfo.layer === 'object' && highlightInfo.obj) {
                    arrowForward = rotateVecByQuat(axis.forward, highlightInfo.obj.rotation);
                    arrowUp = rotateVecByQuat(axis.up, highlightInfo.obj.rotation);
                }
                gl.uniformMatrix4fv(modelLocation, false, createBasisMatrix(arrowForward, arrowUp, scale, position));
                gl.drawArrays(gl.TRIANGLES, 0, arrowVertexCount);
                bindEdgeBuffer(arrowOutlineBuffer);
                gl.uniform3fv(colorLocation, style.outline);
                gl.drawArrays(gl.LINES, 0, arrowOutlineVertexCount);
                if (depthEnabled) {
                    gl.enable(gl.DEPTH_TEST);
                }
            }

            function tryStepUp(position, height, crouching) {
                const originalY = position[1];
                const stepAmount = BLOCK_SCALE + COLLISION_EPSILON;
                position[1] += stepAmount;
                const bounds = getPlayerBounds(position, height);
                if (collidesWithWorld(bounds, crouching) || collidesWithObjects(bounds)) {
                    position[1] = originalY;
                    return false;
                }
                camera.velocityY = Math.max(0, camera.velocityY);
                return true;
            }

            function collidesWithWorld(bounds, crouching) {
                for (const block of placedBlocks) {
                    if (!blockAllowsCollision(block.id, crouching)) continue;
                    if (aabbIntersect(bounds, getBlockBounds(block))) {
                        return true;
                    }
                }
                return false;
            }

            function collidesWithObjects(bounds) {
                for (const obj of worldObjects) {
                    for (const b of obj.blocks) {
                        const aabb = worldObjectBlockAabb(obj, b);
                        if (!aabb) continue;
                        const bb = {
                            minX: aabb.min[0],
                            maxX: aabb.max[0],
                            minY: aabb.min[1],
                            maxY: aabb.max[1],
                            minZ: aabb.min[2],
                            maxZ: aabb.max[2]
                        };
                        if (aabbIntersect(bounds, bb)) {
                            wakeWorldObject(obj);
                            return true;
                        }
                    }
                }
                return false;
            }

            function moveWithCollisions(delta, crouching) {
                const position = camera.position;
                const height = getPlayerHeight(crouching);
                for (let axis = 0; axis < 3; axis++) {
                    const axisDelta = delta[axis];
                    if (!axisDelta) continue;
                    const oldPos = position[axis];
                    position[axis] += axisDelta;
                    let bounds = getPlayerBounds(position, height);
                    const hitWorld = collidesWithWorld(bounds, crouching);
                    const hitObject = collidesWithObjects(bounds);
                    if (!hitWorld && !hitObject) continue;
                    if (axis !== 1 && tryStepUp(position, height, crouching)) {
                        bounds = getPlayerBounds(position, height);
                        axis = -1;
                        continue;
                    }
                    position[axis] = oldPos; // revert that axis movement
                    bounds = getPlayerBounds(position, height);
                    if (axis === 1) {
                        if (axisDelta < 0) {
                            camera.velocityY = Math.max(0, camera.velocityY);
                            camera.grounded = true;
                            setFlying(false);
                        } else if (axisDelta > 0) {
                            camera.velocityY = Math.min(0, camera.velocityY);
                        }
                    }
                }
            }

            function drawPreviewCellsAtWorld(worldCenters, style) {
                if (!worldCenters || !worldCenters.length) return;
                const depthEnabled = gl.isEnabled(gl.DEPTH_TEST);
                if (!depthEnabled) {
                    gl.enable(gl.DEPTH_TEST);
                }
                gl.enable(gl.BLEND);
                bindCube();
                gl.uniform1i(checkerLocation, 0);
                gl.uniform1i(useTextureLocation, 0);
                gl.uniform1i(useNormalLocation, 0);
                gl.uniform1i(useAsgLocation, 0);
                gl.uniform1i(useLightingLocation, 0);
                gl.uniform1f(tileLocation, BLOCK_SCALE);
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, fallbackTexture);
                const prevDepthFunc = gl.getParameter(gl.DEPTH_FUNC);
                gl.colorMask(false, false, false, false);
                gl.depthMask(true);
                gl.depthFunc(gl.LESS);
                worldCenters.forEach(entry => {
                    const center = entry.position || entry;
                    const rot = entry.rotation || null;
                    const model = rot ? createTransformMatrix(rot, center) : createTranslationMatrix(center);
                    gl.uniformMatrix4fv(modelLocation, false, model);
                    for (let face = 0; face < cubeFaceDirections.length; face++) {
                        gl.drawArrays(gl.TRIANGLES, cubeFaceOffsets[face], 6);
                    }
                });
                gl.colorMask(true, true, true, true);
                gl.depthMask(false);
                gl.depthFunc(gl.LEQUAL);
                gl.uniform1f(alphaLocation, PREVIEW_FILL_ALPHA);
                gl.uniform3fv(colorLocation, style.fill);
                worldCenters.forEach(entry => {
                    const center = entry.position || entry;
                    const rot = entry.rotation || null;
                    const model = rot ? createTransformMatrix(rot, center) : createTranslationMatrix(center);
                    gl.uniformMatrix4fv(modelLocation, false, model);
                    for (let face = 0; face < cubeFaceDirections.length; face++) {
                        gl.drawArrays(gl.TRIANGLES, cubeFaceOffsets[face], 6);
                    }
                });
                gl.uniform1f(alphaLocation, PREVIEW_OUTLINE_ALPHA);
                gl.uniform3fv(colorLocation, style.outline);
                worldCenters.forEach(entry => {
                    const center = entry.position || entry;
                    const rot = entry.rotation || null;
                    const model = rot ? createTransformMatrix(rot, center) : createTranslationMatrix(center);
                    gl.uniformMatrix4fv(modelLocation, false, model);
                    for (let face = 0; face < cubeFaceDirections.length; face++) {
                        bindEdgeBuffer(cubeFaceEdgeBuffers[face]);
                        gl.drawArrays(gl.LINES, 0, cubeFaceEdgeVertexCounts[face]);
                    }
                });
                gl.uniform1f(alphaLocation, 1);
                gl.depthMask(true);
                gl.depthFunc(prevDepthFunc);
                if (!depthEnabled) {
                    gl.disable(gl.DEPTH_TEST);
                }
            }

            function bindBufferAttributes(buffer, strideFloats, hasNormal) {
                gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
                const stride = strideFloats * Float32Array.BYTES_PER_ELEMENT;
                gl.enableVertexAttribArray(positionLocation);
                gl.vertexAttribPointer(positionLocation, 3, gl.FLOAT, false, stride, 0);
                gl.enableVertexAttribArray(uvLocation);
                gl.vertexAttribPointer(uvLocation, 2, gl.FLOAT, false, stride, 3 * Float32Array.BYTES_PER_ELEMENT);
                if (hasNormal) {
                    gl.enableVertexAttribArray(normalLocation);
                    gl.vertexAttribPointer(
                        normalLocation,
                        3,
                        gl.FLOAT,
                        false,
                        stride,
                        5 * Float32Array.BYTES_PER_ELEMENT
                    );
                } else {
                    gl.disableVertexAttribArray(normalLocation);
                    gl.vertexAttrib3f(normalLocation, 0, 1, 0);
                }
            }

            function bindPlane() {
                bindBufferAttributes(planeBuffer, 8, true);
            }

            function bindCube() {
                bindBufferAttributes(cubeBuffer, 8, true);
            }
            function bindEdgeBuffer(buffer) {
                bindBufferAttributes(buffer, 5, false);
            }
            function bindMeshBuffers(mesh) {
                if (!mesh) return;
                gl.bindBuffer(gl.ARRAY_BUFFER, mesh.positionBuffer);
                gl.enableVertexAttribArray(positionLocation);
                gl.vertexAttribPointer(positionLocation, 3, gl.FLOAT, false, 0, 0);
                if (mesh.uvBuffer) {
                    gl.bindBuffer(gl.ARRAY_BUFFER, mesh.uvBuffer);
                    gl.enableVertexAttribArray(uvLocation);
                    gl.vertexAttribPointer(uvLocation, 2, gl.FLOAT, false, 0, 0);
                } else {
                    gl.disableVertexAttribArray(uvLocation);
                    gl.vertexAttrib2f(uvLocation, 0, 0);
                }
                if (mesh.normalBuffer) {
                    gl.bindBuffer(gl.ARRAY_BUFFER, mesh.normalBuffer);
                    gl.enableVertexAttribArray(normalLocation);
                    gl.vertexAttribPointer(normalLocation, 3, gl.FLOAT, false, 0, 0);
                } else {
                    gl.disableVertexAttribArray(normalLocation);
                    gl.vertexAttrib3f(normalLocation, 0, 1, 0);
                }
                if (mesh.indexBuffer) {
                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, mesh.indexBuffer);
                }
            }
            function createPerspectiveMatrix(fovRadians, aspect, near, far) {
                const f = 1.0 / Math.tan(fovRadians / 2);
                const rangeInv = 1 / (near - far);
                return new Float32Array([
                    f / aspect, 0, 0, 0,
                    0, f, 0, 0,
                    0, 0, (near + far) * rangeInv, -1,
                    0, 0, near * far * rangeInv * 2, 0
                ]);
            }

            function normalizeVec(vec) {
                const len = Math.hypot(vec[0], vec[1], vec[2]);
                return len ? [vec[0] / len, vec[1] / len, vec[2] / len] : [0, 0, 0];
            }

            function subtract(a, b) {
                return [a[0] - b[0], a[1] - b[1], a[2] - b[2]];
            }

            function cross(a, b) {
                return [
                    a[1] * b[2] - a[2] * b[1],
                    a[2] * b[0] - a[0] * b[2],
                    a[0] * b[1] - a[1] * b[0]
                ];
            }

            function dot(a, b) {
                return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
            }

            function add(a, b) {
                return [a[0] + b[0], a[1] + b[1], a[2] + b[2]];
            }

            function scaleVec(v, s) {
                return [v[0] * s, v[1] * s, v[2] * s];
            }

            function mat3Multiply(a, b) {
                return [
                    a[0] * b[0] + a[1] * b[3] + a[2] * b[6],
                    a[0] * b[1] + a[1] * b[4] + a[2] * b[7],
                    a[0] * b[2] + a[1] * b[5] + a[2] * b[8],
                    a[3] * b[0] + a[4] * b[3] + a[5] * b[6],
                    a[3] * b[1] + a[4] * b[4] + a[5] * b[7],
                    a[3] * b[2] + a[4] * b[5] + a[5] * b[8],
                    a[6] * b[0] + a[7] * b[3] + a[8] * b[6],
                    a[6] * b[1] + a[7] * b[4] + a[8] * b[7],
                    a[6] * b[2] + a[7] * b[5] + a[8] * b[8]
                ];
            }

            function mat3Transpose(m) {
                return [
                    m[0], m[3], m[6],
                    m[1], m[4], m[7],
                    m[2], m[5], m[8]
                ];
            }

            function mat3MultiplyVec(m, v) {
                return [
                    m[0] * v[0] + m[1] * v[1] + m[2] * v[2],
                    m[3] * v[0] + m[4] * v[1] + m[5] * v[2],
                    m[6] * v[0] + m[7] * v[1] + m[8] * v[2]
                ];
            }

            function mat3Invert(m) {
                const a00 = m[0], a01 = m[1], a02 = m[2];
                const a10 = m[3], a11 = m[4], a12 = m[5];
                const a20 = m[6], a21 = m[7], a22 = m[8];
                const b01 = a22 * a11 - a12 * a21;
                const b11 = -a22 * a10 + a12 * a20;
                const b21 = a21 * a10 - a11 * a20;
                let det = a00 * b01 + a01 * b11 + a02 * b21;
                if (!det) {
                    return [0, 0, 0, 0, 0, 0, 0, 0, 0];
                }
                det = 1 / det;
                return [
                    b01 * det,
                    (-a22 * a01 + a02 * a21) * det,
                    (a12 * a01 - a02 * a11) * det,
                    b11 * det,
                    (a22 * a00 - a02 * a20) * det,
                    (-a12 * a00 + a02 * a10) * det,
                    b21 * det,
                    (-a21 * a00 + a01 * a20) * det,
                    (a11 * a00 - a01 * a10) * det
                ];
            }

            function quatToMat3(quat) {
                const q = quatNormalize(quat);
                const x = q[0], y = q[1], z = q[2], w = q[3];
                const xx = x * x, yy = y * y, zz = z * z;
                const xy = x * y, xz = x * z, yz = y * z;
                const wx = w * x, wy = w * y, wz = w * z;
                return [
                    1 - 2 * (yy + zz), 2 * (xy - wz), 2 * (xz + wy),
                    2 * (xy + wz), 1 - 2 * (xx + zz), 2 * (yz - wx),
                    2 * (xz - wy), 2 * (yz + wx), 1 - 2 * (xx + yy)
                ];
            }

            function getQuatAxes(quat) {
                const xAxis = rotateVecByQuat([1, 0, 0], quat);
                const yAxis = rotateVecByQuat([0, 1, 0], quat);
                const zAxis = rotateVecByQuat([0, 0, 1], quat);
                return [xAxis, yAxis, zAxis];
            }

            function quatMultiply(a, b) {
                return [
                    a[3] * b[0] + a[0] * b[3] + a[1] * b[2] - a[2] * b[1],
                    a[3] * b[1] - a[0] * b[2] + a[1] * b[3] + a[2] * b[0],
                    a[3] * b[2] + a[0] * b[1] - a[1] * b[0] + a[2] * b[3],
                    a[3] * b[3] - a[0] * b[0] - a[1] * b[1] - a[2] * b[2]
                ];
            }

            function quatNormalize(q) {
                const len = Math.hypot(q[0], q[1], q[2], q[3]) || 1;
                return [q[0] / len, q[1] / len, q[2] / len, q[3] / len];
            }

            function quatFromAxisAngle(axis, angle) {
                const half = angle * 0.5;
                const s = Math.sin(half);
                return [axis[0] * s, axis[1] * s, axis[2] * s, Math.cos(half)];
            }

            function quatConjugate(q) {
                return [-q[0], -q[1], -q[2], q[3]];
            }

            function rotateVecByQuat(v, q) {
                const u = [q[0], q[1], q[2]];
                const s = q[3];
                const uv = cross(u, v);
                const uuv = cross(u, uv);
                return [
                    v[0] + 2 * (s * uv[0] + uuv[0]),
                    v[1] + 2 * (s * uv[1] + uuv[1]),
                    v[2] + 2 * (s * uv[2] + uuv[2])
                ];
            }

            function rotateVecByQuatInv(v, q) {
                return rotateVecByQuat(v, quatConjugate(q));
            }

            function quatToMat3Inv(quat) {
                const q = quatConjugate(quatNormalize(quat));
                const x = q[0], y = q[1], z = q[2], w = q[3];
                const xx = x * x, yy = y * y, zz = z * z;
                const xy = x * y, xz = x * z, yz = y * z;
                const wx = w * x, wy = w * y, wz = w * z;
                return new Float32Array([
                    1 - 2 * (yy + zz), 2 * (xy + wz), 2 * (xz - wy),
                    2 * (xy - wz), 1 - 2 * (xx + zz), 2 * (yz + wx),
                    2 * (xz + wy), 2 * (yz - wx), 1 - 2 * (xx + yy)
                ]);
            }

            function normalizeVecSafe(v) {
                const len = Math.hypot(v[0], v[1], v[2]);
                if (len > 0) {
                    return [v[0] / len, v[1] / len, v[2] / len];
                }
                return [0, 0, 0];
            }

            function createLookAtMatrix(position, target, up) {
                const zAxis = normalizeVec(subtract(position, target));
                const xAxis = normalizeVec(cross(up, zAxis));
                const yAxis = cross(zAxis, xAxis);
                return new Float32Array([
                    xAxis[0], yAxis[0], zAxis[0], 0,
                    xAxis[1], yAxis[1], zAxis[1], 0,
                    xAxis[2], yAxis[2], zAxis[2], 0,
                    -dot(xAxis, position), -dot(yAxis, position), -dot(zAxis, position), 1
                ]);
            }

            function createTranslationMatrix(position, uniformScale = BLOCK_SCALE) {
                return new Float32Array([
                    uniformScale, 0, 0, 0,
                    0, uniformScale, 0, 0,
                    0, 0, uniformScale, 0,
                    position[0], position[1], position[2], 1
                ]);
            }

            function createTransformMatrix(quat, position, uniformScale = BLOCK_SCALE) {
                const x = quat[0], y = quat[1], z = quat[2], w = quat[3];
                const xx = x * x, yy = y * y, zz = z * z;
                const xy = x * y, xz = x * z, yz = y * z;
                const wx = w * x, wy = w * y, wz = w * z;
                return new Float32Array([
                    (1 - 2 * (yy + zz)) * uniformScale, (2 * (xy + wz)) * uniformScale, (2 * (xz - wy)) * uniformScale, 0,
                    (2 * (xy - wz)) * uniformScale, (1 - 2 * (xx + zz)) * uniformScale, (2 * (yz + wx)) * uniformScale, 0,
                    (2 * (xz + wy)) * uniformScale, (2 * (yz - wx)) * uniformScale, (1 - 2 * (xx + yy)) * uniformScale, 0,
                    position[0], position[1], position[2], 1
                ]);
            }

            function createBasisMatrix(forward, upHint, scale, position) {
                let zAxis = normalizeVec(forward);
                if (!zAxis[0] && !zAxis[1] && !zAxis[2]) {
                    zAxis = [0, 1, 0];
                }
                let yAxis = normalizeVec(upHint);
                if (!yAxis[0] && !yAxis[1] && !yAxis[2]) {
                    yAxis = [0, 0, 1];
                }
                let xAxis = normalizeVec(cross(yAxis, zAxis));
                if (!xAxis[0] && !xAxis[1] && !xAxis[2]) {
                    yAxis = [1, 0, 0];
                    xAxis = normalizeVec(cross(yAxis, zAxis));
                }
                yAxis = normalizeVec(cross(zAxis, xAxis));
                return new Float32Array([
                    xAxis[0] * scale, yAxis[0] * scale, zAxis[0] * scale, 0,
                    xAxis[1] * scale, yAxis[1] * scale, zAxis[1] * scale, 0,
                    xAxis[2] * scale, yAxis[2] * scale, zAxis[2] * scale, 0,
                    position[0], position[1], position[2], 1
                ]);
            }

            function resizeCanvas() {
                const dpr = window.devicePixelRatio || 1;
                const displayWidth = Math.floor(canvas.clientWidth * dpr);
                const displayHeight = Math.floor(canvas.clientHeight * dpr);
                if (canvas.width !== displayWidth || canvas.height !== displayHeight) {
                    canvas.width = displayWidth;
                    canvas.height = displayHeight;
                    gl.viewport(0, 0, canvas.width, canvas.height);
                }
            }

            function triggerJumpImpulse() {
                if (!isFlying && camera.grounded) {
                    camera.velocityY = 7.235;
                    camera.grounded = false;
                }
            }

            function updateCamera(delta) {
                if (menuOpen) return;
                const sprinting = isActionActive('sprint');
                const wantCrouch = !isFlying && isActionActive('crouch');
                if (!isFlying) {
                    setCrouchState(wantCrouch, !camera.grounded);
                } else {
                    setCrouchState(false);
                }
                const crouching = crouchState;
                let moveSpeed;
                if (isFlying) {
                    const preset = getFlightSpeedPreset();
                    moveSpeed = sprinting ? preset.baseSpeed * 2 : preset.baseSpeed;
                } else {
                    moveSpeed = sprinting ? 10 : 6;
                }
                if (!isFlying && crouching) {
                    moveSpeed *= 0.3;
                }
                const forward = [Math.sin(camera.yaw), 0, Math.cos(camera.yaw)];
                const right = [Math.sin(camera.yaw - Math.PI / 2), 0, Math.cos(camera.yaw - Math.PI / 2)];
                const movement = [0, 0, 0];

                if (isActionActive('moveForward')) {
                    movement[0] += forward[0];
                    movement[2] += forward[2];
                }
                if (isActionActive('moveBackward')) {
                    movement[0] -= forward[0];
                    movement[2] -= forward[2];
                }
                if (isActionActive('moveLeft')) {
                    movement[0] -= right[0];
                    movement[2] -= right[2];
                }
                if (isActionActive('moveRight')) {
                    movement[0] += right[0];
                    movement[2] += right[2];
                }

                const direction = normalizeVec(movement);
                const desiredVelocity = [
                    direction[0] * moveSpeed,
                    0,
                    direction[2] * moveSpeed
                ];

                if (isFlying) {
                    camera.velocityY = 0;
                    let vertical = 0;
                    if (isActionActive('jump')) vertical += 1;
                    if (isActionActive('crouch')) vertical -= 1;
                    desiredVelocity[1] = vertical * moveSpeed;
                } else {
                    desiredVelocity[1] = 0;
                    camera.velocityY += -19.62 * delta;
                }

                const friction = isFlying ? AIR_FRICTION : GROUND_FRICTION;
                const lerpFactor = Math.min(1, friction * delta);
                for (let i = 0; i < 3; i++) {
                    movementVelocity[i] += (desiredVelocity[i] - movementVelocity[i]) * lerpFactor;
                    if (Math.abs(movementVelocity[i]) < 0.0001) {
                        movementVelocity[i] = 0;
                    }
                }
                if (!isFlying) {
                    movementVelocity[1] = 0;
                }
                const deltaMotion = [
                    movementVelocity[0] * delta,
                    isFlying ? movementVelocity[1] * delta : camera.velocityY * delta,
                    movementVelocity[2] * delta
                ];

                if (jumpHoldActive) {
                    jumpHoldTimer += delta;
                    if (!isFlying && camera.grounded) {
                        triggerJumpImpulse();
                    }
                }

                camera.grounded = false;
                moveWithCollisions(deltaMotion, crouching);

                if (!isFlying) {
                    const minHeight = getPlayerHeight(crouching);
                    if (camera.position[1] < minHeight) {
                        camera.position[1] = minHeight;
                        camera.velocityY = 0;
                        camera.grounded = true;
                        setFlying(false);
                    }
                } else {
                    const standHeight = getPlayerHeight(false);
                    if (camera.position[1] <= standHeight) {
                        camera.position[1] = standHeight;
                        camera.velocityY = 0;
                        camera.grounded = true;
                        setFlying(false);
                    } else if (crouchState) {
                        setCrouchState(false);
                    }
                }
            }

            function placeBlock(forcedItemId) {
                const itemId = forcedItemId || hotbarSlots[selectedHotbar];
                if (!itemId || !highlightInfo) return false;
                const crouching = crouchState;
                if (highlightInfo.layer === 'object' && highlightInfo.obj) {
                    let targetGrid = null;
                    if (highlightInfo.normal) {
                        targetGrid = highlightInfo.block && highlightInfo.block.grid ? [
                            highlightInfo.block.grid[0] + highlightInfo.normal[0],
                            highlightInfo.block.grid[1] + highlightInfo.normal[1],
                            highlightInfo.block.grid[2] + highlightInfo.normal[2]
                        ] : highlightInfo.position && highlightInfo.position.slice();
                    } else {
                        targetGrid = highlightInfo.block && highlightInfo.block.grid ? highlightInfo.block.grid.slice() : null;
                    }
                    if (!targetGrid) return false;
                    return placeObjectBlock({ obj: highlightInfo.obj, position: targetGrid }, itemId);
                } else {
                    const targetGrid = getPlacementTargetFromHighlight(highlightInfo, crouching);
                    if (!targetGrid) return false;
                    const allowReplace = highlightInfo.type === 'block' && highlightInfo.block && !crouching && REPLACEABLE_BLOCKS.has(highlightInfo.block.id);
                    return tryPlaceAt(targetGrid, itemId, allowReplace);
                }
            }

            function triggerPulseImpulse() {
                if (menuOpen || inventoryOpen) return;
                const dir = normalizeVec([
                    Math.cos(camera.pitch) * Math.sin(camera.yaw),
                    Math.sin(camera.pitch),
                    Math.cos(camera.pitch) * Math.cos(camera.yaw)
                ]);
                const origin = camera.position.slice();
                const hit = raycastBlocksWithMaxDistance(origin, dir, PULSE_DISTANCE_BLOCKS);
                if (hit && hit.layer === 'object' && hit.obj) {
                    const impulse = [
                        dir[0] * PULSE_IMPULSE,
                        dir[1] * PULSE_IMPULSE,
                        dir[2] * PULSE_IMPULSE
                    ];
                    const hitPos = [
                        origin[0] + dir[0] * (hit.distance * BLOCK_SCALE),
                        origin[1] + dir[1] * (hit.distance * BLOCK_SCALE),
                        origin[2] + dir[2] * (hit.distance * BLOCK_SCALE)
                    ];
                    const comWorld = worldObjectBlockWorldPosition(hit.obj, { offset: hit.obj.com || [0, 0, 0] });
                    const r = [
                        hitPos[0] - comWorld[0],
                        hitPos[1] - comWorld[1],
                        hitPos[2] - comWorld[2]
                    ];
                    const torque = cross(r, impulse);
                    const angularImpulse = [
                        torque[0] * PULSE_ANGULAR_SCALE,
                        torque[1] * PULSE_ANGULAR_SCALE,
                        torque[2] * PULSE_ANGULAR_SCALE
                    ];
                    applyImpulseToObject(hit.obj, impulse, angularImpulse);
                }
            }

            function breakBlock() {
                if (!highlightInfo || highlightInfo.type !== 'block' || !highlightInfo.block) return false;
                if (highlightInfo.layer === 'object' && highlightInfo.obj) {
                    // Remove from world object while keeping it interactive
                    const obj = highlightInfo.obj;
                    const idx = typeof highlightInfo.blockIndex === 'number' ? highlightInfo.blockIndex : obj.blocks.indexOf(highlightInfo.block);
                    if (idx !== -1) {
                        removeObjectBlockAt(obj, idx);
                    }
                    return true;
                }
                removeBlock(highlightInfo.block);
                return true;
            }

            function placeObjectBlock(info, itemId) {
                if (!info || !info.obj || !info.position) return false;
                const obj = info.obj;
                const target = info.position.slice();
                const existing = obj.blocks.find(b =>
                    b.offset[0] === target[0] &&
                    b.offset[1] === target[1] &&
                    b.offset[2] === target[2]
                );
                if (existing) return false;
                obj.blocks.push({
                    id: itemId,
                    offset: target.slice(),
                    color: (getItemDef(itemId) && getItemDef(itemId).color) || [0.8, 0.2, 0.2]
                });
                refreshObjectProperties(obj);
                wakeWorldObject(obj);
                return true;
            }

            function updateHighlight() {
                highlightInfo = raycastBlocks();
                if (!highlightInfo) {
                    highlightInfo = raycastGround();
                }
                if (dragState) {
                    updateDragPreviewFromHighlight();
                }
                updateHoverPreviews();
            }

            function raycastBlocks() {
                const originGrid = worldToGrid(camera.position);
                const dir = normalizeVec(lookDirection);
                const dirGrid = dir.slice();
                // Raycast against world objects first
                const objectHit = raycastWorldObjects(camera.position, dir);
                let best = objectHit;
                let bestDistance = objectHit ? objectHit.distance : Infinity;
                const current = [
                    Math.floor(originGrid[0]),
                    Math.floor(originGrid[1]),
                    Math.floor(originGrid[2])
                ];
                const step = [
                    dirGrid[0] > 0 ? 1 : (dirGrid[0] < 0 ? -1 : 0),
                    dirGrid[1] > 0 ? 1 : (dirGrid[1] < 0 ? -1 : 0),
                    dirGrid[2] > 0 ? 1 : (dirGrid[2] < 0 ? -1 : 0)
                ];
                const tMax = [0, 0, 0];
                const tDelta = [0, 0, 0];
                for (let axis = 0; axis < 3; axis++) {
                    if (step[axis] === 0) {
                        tMax[axis] = Infinity;
                        tDelta[axis] = Infinity;
                        continue;
                    }
                    const boundary = step[axis] > 0 ? current[axis] + 1 : current[axis];
                    tMax[axis] = Math.abs((boundary - originGrid[axis]) / dirGrid[axis]);
                    tDelta[axis] = Math.abs(1 / dirGrid[axis]);
                }
                let currentDistance = 0;
                let lastNormal = null;
                for (let i = 0; i < 256; i++) {
                    if (currentDistance > MAX_INTERACT_DISTANCE) {
                        break;
                    }
                    const block = getBlockAtGrid(current);
                    if (block) {
                        const worldHit = {
                            type: 'block',
                            position: current.slice(),
                            block,
                            normal: lastNormal ? lastNormal.slice() : null,
                            distance: currentDistance,
                            layer: 'world'
                        };
                        if (worldHit.distance <= bestDistance) {
                            return worldHit;
                        }
                        return best;
                    }
                    let axis = 0;
                    if (tMax[1] < tMax[axis]) axis = 1;
                    if (tMax[2] < tMax[axis]) axis = 2;
                    if (tMax[axis] === Infinity) break;
                    currentDistance = tMax[axis];
                    if (best && currentDistance >= bestDistance) {
                        return best;
                    }
                    if (currentDistance > MAX_INTERACT_DISTANCE) {
                        return best || null;
                    }
                    current[axis] += step[axis];
                    tMax[axis] += tDelta[axis];
                    lastNormal = [0, 0, 0];
                    lastNormal[axis] = -step[axis];
                }
                return best || null;
            }

            function raycastBlocksWithMaxDistance(origin, dir, maxDistance) {
                const originGrid = worldToGrid(origin);
                const dirNorm = normalizeVec(dir);
                const dirGrid = dirNorm.slice();
                const objectHit = raycastWorldObjects(origin, dirNorm);
                let best = (objectHit && objectHit.distance <= maxDistance) ? objectHit : null;
                let bestDistance = best ? best.distance : Infinity;
                const current = [
                    Math.floor(originGrid[0]),
                    Math.floor(originGrid[1]),
                    Math.floor(originGrid[2])
                ];
                const step = [
                    dirGrid[0] > 0 ? 1 : (dirGrid[0] < 0 ? -1 : 0),
                    dirGrid[1] > 0 ? 1 : (dirGrid[1] < 0 ? -1 : 0),
                    dirGrid[2] > 0 ? 1 : (dirGrid[2] < 0 ? -1 : 0)
                ];
                const tMax = [0, 0, 0];
                const tDelta = [0, 0, 0];
                for (let axis = 0; axis < 3; axis++) {
                    if (step[axis] === 0) {
                        tMax[axis] = Infinity;
                        tDelta[axis] = Infinity;
                        continue;
                    }
                    const boundary = step[axis] > 0 ? current[axis] + 1 : current[axis];
                    tMax[axis] = Math.abs((boundary - originGrid[axis]) / dirGrid[axis]);
                    tDelta[axis] = Math.abs(1 / dirGrid[axis]);
                }
                let currentDistance = 0;
                let lastNormal = null;
                for (let i = 0; i < 256; i++) {
                    if (currentDistance > maxDistance) {
                        break;
                    }
                    const block = getBlockAtGrid(current);
                    if (block) {
                        const worldHit = {
                            type: 'block',
                            position: current.slice(),
                            block,
                            normal: lastNormal ? lastNormal.slice() : null,
                            distance: currentDistance,
                            layer: 'world'
                        };
                        if (worldHit.distance <= bestDistance) {
                            return worldHit;
                        }
                        return best;
                    }
                    let axis = 0;
                    if (tMax[1] < tMax[axis]) axis = 1;
                    if (tMax[2] < tMax[axis]) axis = 2;
                    if (tMax[axis] === Infinity) break;
                    currentDistance = tMax[axis];
                    if (best && currentDistance >= bestDistance) {
                        return best;
                    }
                    if (currentDistance > maxDistance) {
                        return best || null;
                    }
                    current[axis] += step[axis];
                    tMax[axis] += tDelta[axis];
                    lastNormal = [0, 0, 0];
                    lastNormal[axis] = -step[axis];
                }
                return best || null;
            }

            function raycastGround() {
                if (lookDirection[1] >= 0) return null;
                const origin = camera.position;
                const t = (0 - origin[1]) / lookDirection[1];
                const distance = t * INV_BLOCK_SCALE;
                if (t <= 0 || distance > MAX_INTERACT_DISTANCE) return null;
                const hitPoint = [
                    origin[0] + lookDirection[0] * t,
                    0,
                    origin[2] + lookDirection[2] * t
                ];
                const gridPoint = worldToGrid(hitPoint);
                return {
                    type: 'ground',
                    position: [
                        Math.floor(gridPoint[0]),
                        0,
                        Math.floor(gridPoint[2])
                    ],
                    normal: [0, 1, 0],
                    distance
                };
            }

            let previousTime = 0;
            function render(time) {
                const delta = (time - previousTime) / 1000;
                previousTime = time;
                resizeCanvas();
                updateCamera(delta);
                if (supportDirty) {
                    checkForUnsupportedComponents();
                }
                updateWorldObjects(delta);

                gl.clearColor(0.01, 0.01, 0.02, 1);
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
                gl.enable(gl.DEPTH_TEST);

                const aspect = canvas.width / canvas.height;
                const projection = createPerspectiveMatrix(settings.fov * Math.PI / 180, aspect, 0.1, 800);
                lookDirection = [
                    Math.cos(camera.pitch) * Math.sin(camera.yaw),
                    Math.sin(camera.pitch),
                    Math.cos(camera.pitch) * Math.cos(camera.yaw)
                ];
                const target = [
                    camera.position[0] + lookDirection[0],
                    camera.position[1] + lookDirection[1],
                    camera.position[2] + lookDirection[2]
                ];
                const view = createLookAtMatrix(camera.position, target, [0, 1, 0]);
                updateHighlight();
                updateBreakHold(time);

                gl.uniformMatrix4fv(projectionLocation, false, projection);
                gl.uniformMatrix4fv(viewLocation, false, view);
                gl.uniform3fv(cameraPosLocation, camera.position);
                gl.uniform1f(alphaLocation, 1);

                bindPlane();
                gl.uniformMatrix4fv(modelLocation, false, identityMatrix);
                gl.uniform1i(checkerLocation, 1);
                gl.uniform1i(useTextureLocation, 0);
                gl.uniform1i(useNormalLocation, 0);
                gl.uniform1i(useAsgLocation, 0);
                gl.uniform1i(useLightingLocation, 0);
                gl.uniform1f(tileLocation, 1);
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, fallbackTexture);
                gl.uniform3fv(colorLocation, [0, 0, 0]);
                gl.drawArrays(gl.TRIANGLES, 0, 6);

                if (placedBlocks.length) {
                    const opaqueBlocks = [];
                    const transparentBlocks = [];
                    placedBlocks.forEach(block => {
                        const def = getItemDef(block.id);
                        const opacity = def && typeof def.opacity === 'number' ? def.opacity : 1;
                        if (opacity < 1) {
                            transparentBlocks.push(block);
                        } else {
                            opaqueBlocks.push(block);
                        }
                    });
                    bindCube();
                    gl.uniform1i(checkerLocation, 0);
                    gl.uniform3fv(textureAnchorLocation, [0, 0, 0]);
                    gl.uniform3fv(objectOriginLocation, [0, 0, 0]);
                    gl.uniformMatrix3fv(textureRotInvLocation, false, new Float32Array([
                        1, 0, 0,
                        0, 1, 0,
                        0, 0, 1
                    ]));
                    const drawBlock = block => {
                        const def = getItemDef(block.id);
                    const material = def ? blockTextures.get(def.id) : null;
                    const albedo = material ? material.albedo : null;
                    const normal = material ? material.normal : null;
                    const asg = material ? material.asg : null;
                    const opacity = def && typeof def.opacity === 'number' ? def.opacity : 1;
                    gl.uniform1i(useMeshUvLocation, 0);
                    if (isCanisterItem(block.id)) {
                        ensureCanisterMesh(block.id);
                        const groupInfo = getGroupAnchorAndOrientation(block);
                        if (groupInfo.anchorKey && block.key && groupInfo.anchorKey !== block.key) {
                            return;
                            }
                            if (getCanisterMesh(block.id)) {
                                gl.uniform1f(alphaLocation, opacity);
                                drawCanisterMeshInstance(block, def, material, groupInfo);
                                return;
                            }
                        }
                        if (def && def.texturePath && albedo) {
                            gl.uniform1i(useMeshUvLocation, 0);
                            gl.uniform1i(useTextureLocation, 1);
                            let tile = BLOCK_SCALE * (def.tiling || 1);
                            if (isCanisterItem(block.id)) {
                                const canDef = getCanisterDefinition(block.id);
                                const sz = canDef ? canDef.size : null;
                                if (sz) {
                                    const maxDim = Math.max(sz.x || 1, sz.y || 1, sz.z || 1);
                                    tile = BLOCK_SCALE * maxDim;
                                }
                            }
                            gl.uniform1f(tileLocation, tile);
                            gl.uniform1i(useNormalLocation, normal ? 1 : 0);
                            gl.uniform1i(useAsgLocation, asg ? 1 : 0);
                            gl.uniform1i(useLightingLocation, 1);
                            gl.uniform3fv(colorLocation, block.color);
                            gl.activeTexture(gl.TEXTURE0);
                            gl.bindTexture(gl.TEXTURE_2D, albedo);
                            gl.activeTexture(gl.TEXTURE1);
                            gl.bindTexture(gl.TEXTURE_2D, normal || neutralNormalTexture);
                            gl.activeTexture(gl.TEXTURE2);
                            gl.bindTexture(gl.TEXTURE_2D, asg || neutralAsgTexture);
                        } else {
                            gl.uniform1i(useTextureLocation, 0);
                            gl.uniform1f(tileLocation, BLOCK_SCALE);
                            gl.uniform1i(useNormalLocation, 0);
                            gl.uniform1i(useAsgLocation, 0);
                            gl.uniform1i(useLightingLocation, 1);
                            gl.uniform3fv(colorLocation, block.color);
                            gl.activeTexture(gl.TEXTURE0);
                            gl.bindTexture(gl.TEXTURE_2D, fallbackTexture);
                            gl.activeTexture(gl.TEXTURE1);
                            gl.bindTexture(gl.TEXTURE_2D, neutralNormalTexture);
                            gl.activeTexture(gl.TEXTURE2);
                            gl.bindTexture(gl.TEXTURE_2D, neutralAsgTexture);
                        }
                        gl.uniform1f(alphaLocation, opacity);
                        gl.uniformMatrix4fv(modelLocation, false, createTranslationMatrix(block.position));
                        const blockIsTransparent = isTransparentBlock(block);
                        const blockIsSeeThrough = isSeeThroughBlock(block);
                        const drawFaces = () => {
                            for (let face = 0; face < cubeFaceDirections.length; face++) {
                                const dir = cubeFaceDirections[face];
                                if (dir[1] === -1 && block.grid[1] === 0) {
                                    continue;
                                }
                                const neighbor = getBlockAtGrid([
                                    block.grid[0] + dir[0],
                                    block.grid[1] + dir[1],
                                    block.grid[2] + dir[2]
                                ]);
                                if (neighbor) {
                                    if (neighbor.id === block.id) {
                                        continue;
                                    }
                                    if (blockIsSeeThrough) {
                                        continue;
                                    }
                                    if (isSeeThroughBlock(neighbor)) {
                                        // Opaque renders, see-through does not.
                                    } else if (compareGrid(block.grid, neighbor.grid) <= 0) {
                                        continue;
                                    }
                                }
                                gl.drawArrays(gl.TRIANGLES, cubeFaceOffsets[face], 6);
                            }
                        };
                        if (blockIsTransparent) {
                            gl.enable(gl.CULL_FACE);
                            gl.cullFace(gl.FRONT);
                            drawFaces();
                            gl.cullFace(gl.BACK);
                            drawFaces();
                            gl.disable(gl.CULL_FACE);
                        } else {
                            drawFaces();
                        }
                    };
                    opaqueBlocks.forEach(drawBlock);
                    if (transparentBlocks.length) {
                        const camPos = camera.position;
                        transparentBlocks.sort((a, b) => {
                            const dxA = a.position[0] - camPos[0];
                            const dyA = a.position[1] - camPos[1];
                            const dzA = a.position[2] - camPos[2];
                            const dxB = b.position[0] - camPos[0];
                            const dyB = b.position[1] - camPos[1];
                            const dzB = b.position[2] - camPos[2];
                            return (dxB * dxB + dyB * dyB + dzB * dzB) - (dxA * dxA + dyA * dyA + dzA * dzA);
                        });
                        gl.depthMask(false);
                        transparentBlocks.forEach(drawBlock);
                        gl.depthMask(true);
                    }
                    gl.uniform1f(alphaLocation, 1);
                }
                if (worldObjects.length) {
                    bindCube();
                    gl.uniform1i(checkerLocation, 0);
                    worldObjects.forEach(obj => {
                        const anchor = obj.textureAnchorLocal
                            ? obj.textureAnchorLocal
                            : rotateVecByQuatInv(obj.origin, obj.rotation);
                        gl.uniform3fv(textureAnchorLocation, anchor);
                        gl.uniform3fv(objectOriginLocation, obj.origin);
                        gl.uniformMatrix3fv(textureRotInvLocation, false, quatToMat3Inv(obj.rotation));
                        obj.blocks.forEach(b => {
                            const def = getItemDef(b.id);
                            const material = def ? blockTextures.get(def.id) : null;
                            const albedo = material ? material.albedo : null;
                            const normal = material ? material.normal : null;
                            const asg = material ? material.asg : null;
                            const opacity = def && typeof def.opacity === 'number' ? def.opacity : 1;
                            const aabb = worldObjectBlockAabb(obj, b);
                            if (!aabb) return;
                            gl.uniform1i(useMeshUvLocation, 0);
                            if (def && def.texturePath && albedo) {
                                gl.uniform1i(useTextureLocation, 1);
                                let tile = BLOCK_SCALE * (def.tiling || 1);
                                gl.uniform1f(tileLocation, tile);
                                gl.uniform1i(useNormalLocation, normal ? 1 : 0);
                                gl.uniform1i(useAsgLocation, asg ? 1 : 0);
                                gl.uniform1i(useLightingLocation, 1);
                                gl.uniform3fv(colorLocation, b.color);
                                gl.activeTexture(gl.TEXTURE0);
                                gl.bindTexture(gl.TEXTURE_2D, albedo);
                                gl.activeTexture(gl.TEXTURE1);
                                gl.bindTexture(gl.TEXTURE_2D, normal || neutralNormalTexture);
                                gl.activeTexture(gl.TEXTURE2);
                                gl.bindTexture(gl.TEXTURE_2D, asg || neutralAsgTexture);
                            } else {
                                gl.uniform1i(useTextureLocation, 0);
                                gl.uniform1f(tileLocation, BLOCK_SCALE);
                                gl.uniform1i(useNormalLocation, 0);
                                gl.uniform1i(useAsgLocation, 0);
                                gl.uniform1i(useLightingLocation, 1);
                                gl.uniform1i(useMeshUvLocation, 0);
                                gl.uniform3fv(colorLocation, b.color);
                                gl.activeTexture(gl.TEXTURE0);
                                gl.bindTexture(gl.TEXTURE_2D, fallbackTexture);
                                gl.activeTexture(gl.TEXTURE1);
                                gl.bindTexture(gl.TEXTURE_2D, neutralNormalTexture);
                                gl.activeTexture(gl.TEXTURE2);
                                gl.bindTexture(gl.TEXTURE_2D, neutralAsgTexture);
                            }
                            gl.uniform1f(alphaLocation, opacity);
                            const center = worldObjectBlockWorldPosition(obj, b);
                            gl.uniformMatrix4fv(modelLocation, false, createTransformMatrix(obj.rotation, center));
                            for (let face = 0; face < 6; face++) {
                                gl.drawArrays(gl.TRIANGLES, cubeFaceOffsets[face], 6);
                            }
                        });
                    });
                    gl.uniform1f(alphaLocation, 1);
                }
                gl.uniform3fv(textureAnchorLocation, [0, 0, 0]);
                gl.uniform3fv(objectOriginLocation, [0, 0, 0]);
                gl.uniformMatrix3fv(textureRotInvLocation, false, new Float32Array([
                    1, 0, 0,
                    0, 1, 0,
                    0, 0, 1
                ]));
                if (placementPreviewWorldCells.length) {
                    drawPreviewCellsAtWorld(placementPreviewWorldCells, PREVIEW_STYLES.place);
                } else if (placementPreviewCells.length) {
                    drawPreviewCells(placementPreviewCells, PREVIEW_STYLES.place);
                }
                if (removalPreviewWorldCells.length) {
                    drawPreviewCellsAtWorld(removalPreviewWorldCells, PREVIEW_STYLES.break);
                } else if (removalPreviewCells.length) {
                    drawPreviewCells(removalPreviewCells, PREVIEW_STYLES.break);
                }
                if (hoverPreviewWorldCells.length && !placementPreviewWorldCells.length && !removalPreviewWorldCells.length) {
                    drawPreviewCellsAtWorld(hoverPreviewWorldCells, PREVIEW_STYLES.hover);
                } else if (hoverPreviewCells.length && !placementPreviewCells.length && !removalPreviewCells.length) {
                    drawPreviewCells(hoverPreviewCells, PREVIEW_STYLES.hover);
                }
                drawAxisArrow();

                requestAnimationFrame(render);
            }

            resizeCanvas(); 
            requestAnimationFrame(render);
        })();
    </script>
</body>
</html>
